// server.ts - Bun HTTP server serving index.html, bundled client, and API endpoints

const port = 3001;

import { rename } from "fs/promises";
import { createOpencodeClient } from "@opencode-ai/sdk";
import {
  listMessages,
  sendMessage as rawSendMessage,
  FIRST_MESSAGE_INSTRUCTION,
} from "./src/oc-client";
import { shouldReuseSummary } from "./src/hash";

// In-memory IP address key-value store (simple list of IPs)
// Accepts only IPv4 dotted quads; prevents duplicates.
const ipStore: string[] = [];
function addIp(ip: string) {
  const trimmed = ip.trim();
  if (!/^\d{1,3}(?:\.\d{1,3}){3}$/.test(trimmed)) return false;
  if (!ipStore.includes(trimmed)) ipStore.push(trimmed);
  return true;
}
function removeIp(ip: string) {
  const idx = ipStore.indexOf(ip.trim());
  if (idx === -1) return false;
  ipStore.splice(idx, 1);
  return true;
}
const IP_STORE_FILE = "ip-store.json";
async function loadIps() {
  try {
    const text = await Bun.file(IP_STORE_FILE).text();
    const arr = JSON.parse(text);
    if (Array.isArray(arr))
      arr.forEach((v) => typeof v === "string" && addIp(v));
  } catch {
    /* no existing file */
  }
}
async function persistIps() {
  try {
    const json = JSON.stringify(ipStore);
    console.log("Persist write start", { count: ipStore.length });
    await Bun.write(IP_STORE_FILE + ".tmp", json);
    await rename(IP_STORE_FILE + ".tmp", IP_STORE_FILE);
    console.log("Persist rename complete");
  } catch (e) {
    console.error("Persist IPs failed", (e as Error).message);
    // Fallback direct write (non-atomic) so we at least have data
    try {
      await Bun.write(IP_STORE_FILE, JSON.stringify(ipStore));
      console.log("Fallback direct write complete");
    } catch (e2) {
      console.error("Fallback persist failed", (e2 as Error).message);
    }
  }
}
await loadIps();

function resolveBaseUrl(ip: string) {
  return `http://${ip}:2000`;
}

// Per-IP ephemeral session cache (5s TTL)
interface CachedSessions {
  list: { id: string; title?: string }[];
  fetchedAt: number;
}
const cachedSessionsByIp: Record<string, CachedSessions | null> = {};
// Per-session summary cache to avoid repeated summarizer calls when no new messages
const summaryCacheBySession: Record<
  string,
  { messageHash: string; summary: string; action: boolean; cachedAt: number }
> = {};
const SUMMARY_CACHE_TTL_MS = 15 * 60 * 1000; // 15m max retention
const SUMMARY_NEGATIVE_TTL_MS = 60 * 1000; // 1m for failed summaries
let lastSummaryPrune = Date.now();
// Track in-flight asynchronous summarization per session key to avoid duplicate calls
const SUMMARY_DEBOUNCE_MS = 2000; // delay before starting summarization to batch bursts
const summaryDebounceTimers: Record<string, ReturnType<typeof setTimeout>> = {};
const inFlightSummary: Record<string, boolean> = {};

// NEW: lightweight message count cache to let advanced SSE reuse counts generated by messages SSE
// Key format: `${ip}::${sessionId}`; TTL is implicit via freshness check (<=5s) before reuse
const messageCountCache: Record<string, { count: number; updatedAt: number }> =
  {};
const MESSAGE_COUNT_FRESH_MS = 5000;
// Advanced aggregated state persistent across SSE reconnects for events view
// Key: `${ip}::${sessionId}`
const advancedAggregatedStateBySession: Record<string, any> = {};

// Derive share URL for a session (best-effort; cached short TTL via advancedAggregatedState)
function deriveShareUrlForSession(ip: string, sid: string): string | undefined {
  try {
    const aggKey = `${ip}::${sid}`;
    const agg = advancedAggregatedStateBySession[aggKey];
    if (agg && typeof agg.shareUrl === "string" && agg.shareUrl)
      return agg.shareUrl;
  } catch {}
  const base = resolveBaseUrl(ip);
  try {
    // Fetch detail; SDK first then raw fallback
    const client = createOpencodeClient({ baseUrl: base });
    return Promise.resolve((client as any).session.get?.({ path: { id: sid } }))
      .then((d: any) => {
        console.log("deriveShareUrlForSession sdk.get raw", {
          ip,
          sid,
          keys: d && Object.keys(d || {}),
          val: d,
        });
        const url =
          d?.share?.url ||
          d?.data?.share?.url ||
          d?.share_url ||
          d?.data?.share_url;
        if (typeof url === "string" && url) {
          try {
            const aggKey = `${ip}::${sid}`;
            const agg =
              advancedAggregatedStateBySession[aggKey] ||
              (advancedAggregatedStateBySession[aggKey] = {});
            agg.shareUrl = url;
          } catch {}
          return url;
        }
        return undefined;
      })
      .catch(() =>
        fetch(`${base}/session/${sid}`)
          .then((r) => (r.ok ? r.json().catch(() => null) : null))
          .then((j: any) => {
            console.log("deriveShareUrlForSession raw fetch detail", {
              ip,
              sid,
              val: j,
            });
            const url =
              j?.share?.url ||
              j?.data?.share?.url ||
              j?.share_url ||
              j?.data?.share_url;
            if (typeof url === "string" && url) {
              try {
                const aggKey = `${ip}::${sid}`;
                const agg =
                  advancedAggregatedStateBySession[aggKey] ||
                  (advancedAggregatedStateBySession[aggKey] = {});
                agg.shareUrl = url;
              } catch {}
              return url;
            }
            return undefined;
          })
          .catch(() => undefined),
      ) as any;
  } catch {
    return undefined;
  }
}

const firstMessageSeen = new Set<string>();
const inFlightFirstMessage: Record<string, boolean> = {};

// Message send queue (fire-and-forget background processing)
interface QueuedMessageJob {
  ip: string;
  sid: string;
  text: string;
  createdAt: number;
  id: string;
  attempts: number;
  status: "pending" | "sending" | "failed" | "sent";
  lastError?: string;
  autoRetried?: boolean; // marks that an automatic retry was scheduled once
}
const queueJobsBySession: Record<string, QueuedMessageJob[]> = {};
const messageSendQueue: QueuedMessageJob[] = []; // global FIFO (also stored per-session)
let messageQueueActive = false;
async function processMessageQueue() {
  if (messageQueueActive) return;
  messageQueueActive = true;
  try {
    while (messageSendQueue.length) {
      const job = messageSendQueue.shift();
      if (!job) break;
      job.attempts++;
      job.status = "sending";
      const { ip, sid, text, createdAt } = job;
      try {
        console.log("Queue dispatch start", {
          ip,
          sid,
          ageMs: Date.now() - createdAt,
        });
        const result = await rawSendMessage(resolveBaseUrl(ip), sid, text);
        if (!result.ok) {
          console.warn("Queue send failed", {
            ip,
            sid,
            status: result.status,
            error: result.error,
          });
          job.status = "failed";
          job.lastError = (result.error || `status ${result.status}`) + "";
          const aggKey = `${ip}::${sid}`;
          const agg = advancedAggregatedStateBySession[aggKey];
          if (agg) {
            agg.summary = `(send failed: retry)`;
            agg.actionFlag = false;
          }
        } else {
          console.log("Queue send ok", { ip, sid });
          job.status = "sent";
          const aggKey2 = `${ip}::${sid}`;
          const agg2 = advancedAggregatedStateBySession[aggKey2];
          if (agg2 && agg2.summary === "(send failed: retry)") {
            agg2.summary = "..."; // placeholder until summarizer recomputes
          }
        }
      } catch (e) {
        console.error("Queue send error", {
          ip,
          sid,
          msg: (e as Error).message,
        });
        job.status = "failed";
        job.lastError = (e as Error).message;
        const aggKey3 = `${ip}::${sid}`;
        const agg3 = advancedAggregatedStateBySession[aggKey3];
        if (agg3) {
          agg3.summary = `(send failed: retry)`;
          agg3.actionFlag = false;
        }
      }
      // Yield to event loop so we don't block
      await new Promise((r) => setTimeout(r, 10));
    }
  } finally {
    messageQueueActive = false;
  }
}
// Periodic queue processor (every 1s) and immediate trigger on push
setInterval(() => processMessageQueue(), 1000);

// Rendering helpers
import {
  renderSessionDetailPage,
  renderSessionAdvancedPage,
  renderSessionsListPage,
} from "./rendering";
import { renderAutoScrollScriptEvent } from "./rendering/fragments";

import { dataStarPatchElementsString } from "./rendering/datastar";
import {
  AdvancedSdkJson,
  AdvancedInfo,
  StatusDiv,
  AdvancedEvents,
  AdvancedRecentMessages,
} from "./rendering/fragments";
import { IpsUl, SessionsUl } from "./rendering/lists";

// Read persisted summarizer session id (if any) for highlighting; returns string or undefined
async function readSummarizerId(): Promise<string | undefined> {
  try {
    const text = await Bun.file("playpen/summarizer-config.json").text();
    const data = JSON.parse(text);
    const id =
      data && typeof data.summarizerSessionId === "string"
        ? data.summarizerSessionId
        : undefined;
    return id;
  } catch {
    return undefined;
  }
}

// Fetch sessions fresh for an IP (no cache usage, but populates cache for quick create-session reflection)
async function fetchSessionsFresh(ip: string) {
  const base = resolveBaseUrl(ip);
  console.log("sessions fetch start", { ip, base });
  try {
    const client = createOpencodeClient({ baseUrl: base });
    const remote = await client.session.list().catch((e: any) => {
      console.warn("SDK session.list error", {
        ip,
        msg: (e && e.message) || String(e),
      });
      return null;
    });
    console.log("SDK session.list raw", {
      ip,
      type: remote && typeof remote,
      keys: remote && Object.keys(remote as any),
      value: remote,
    });
    let list: { id: string; title?: string }[] = [];
    if (Array.isArray(remote)) {
      list = remote.map((r) => ({ id: r.id, title: r.title }));
    } else if (remote && typeof remote === "object") {
      const arr = (remote as any).data || (remote as any).sessions;
      if (Array.isArray(arr))
        list = arr.map((r: any) => ({ id: r.id, title: r.title }));
    }
    if (!list.length) {
      try {
        const rawRes = await fetch(`${base}/session`);
        console.log("raw /session status", { ip, status: rawRes.status });
        if (rawRes.ok) {
          const rawJson = await rawRes.json().catch((e: any) => {
            console.warn("raw /session json parse error", {
              ip,
              msg: (e && e.message) || String(e),
            });
            return null;
          });
          console.log("raw /session json", { ip, value: rawJson });
          const rawArr = Array.isArray(rawJson)
            ? rawJson
            : rawJson?.sessions || rawJson?.data;
          if (Array.isArray(rawArr))
            list = rawArr.map((r: any) => ({ id: r.id, title: r.title }));
        }
      } catch (e) {
        console.warn("raw /session fetch error", {
          ip,
          msg: (e as Error).message,
        });
      }
    }
    const now = Date.now();
    const existing = cachedSessionsByIp[ip];
    if (existing) {
      existing.list = list;
      existing.fetchedAt = now;
    } else {
      cachedSessionsByIp[ip] = { list, fetchedAt: now };
    }
    console.log("sessions fetch complete", { ip, count: list.length });
    return list;
  } catch (e) {
    console.error("Failed to list sessions", ip, (e as Error).message);
    return [];
  }
}

// SSE of sessions for an IP
function sessionsSSE(ip: string): Response {
  let interval: ReturnType<typeof setInterval> | undefined;
  const stream = new ReadableStream({
    async start(controller) {
      async function push() {
        try {
          const list = await fetchSessionsFresh(ip);
          const statusJsx = (
            <div id="sessions-status" class="status">
              {`Updated ${new Date().toLocaleTimeString()}`}
            </div>
          );
          const summarizerId = await readSummarizerId();
          const listWrapperJsx = (
            <div id="sessions-list">
              <IpsUl ips={[]} />
            </div>
          ); // placeholder replaced below
          const sessionsListJsx = (
            <div id="sessions-list">
              <SessionsUl ip={ip} sessions={list} summarizerId={summarizerId} />
            </div>
          );
          try {
            controller.enqueue(
              new TextEncoder().encode(dataStarPatchElementsString(statusJsx)),
            );
            controller.enqueue(
              new TextEncoder().encode(
                dataStarPatchElementsString(sessionsListJsx),
              ),
            );
          } catch (e) {
            if (interval) clearInterval(interval);
            controller.close();
          }
        } catch (e) {
          console.error("Sessions SSE push error", (e as Error).message);
        }
      }
      await push();
      interval = setInterval(push, 5000);
    },
    cancel() {
      if (interval) clearInterval(interval);
    },
  });
  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream; charset=utf-8",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive",
      "Access-Control-Allow-Origin": "*",
    },
  });
}

// Fetch messages for a session at IP
async function fetchMessages(ip: string, sessionId: string) {
  const base = resolveBaseUrl(ip);
  try {
    const textMessages = await listMessages(base, sessionId);
    return textMessages.map((msg) => ({
      role: msg.role,
      text: msg.texts.join("\n"),
      parts: msg.texts.map((text) => ({ type: "text", text })),
    }));
  } catch (e) {
    console.error(
      "Failed to fetch messages",
      ip,
      sessionId,
      (e as Error).message,
    );
    return [];
  }
}

// Legacy messagesSSE removed; advanced events stream now handles messages + summary.

// SSE of IP addresses
function ipsSSE(): Response {
  let interval: ReturnType<typeof setInterval> | undefined;
  const stream = new ReadableStream({
    async start(controller) {
      function build() {
        try {
          const statusJsx = (
            <StatusDiv
              id="ips-status"
              text={`Updated ${new Date().toLocaleTimeString()}`}
            />
          );
          const ipsJsx = <IpsUl ips={ipStore} />;
          try {
            controller.enqueue(
              new TextEncoder().encode(dataStarPatchElementsString(statusJsx)),
            );
            controller.enqueue(
              new TextEncoder().encode(dataStarPatchElementsString(ipsJsx)),
            );
          } catch (e) {
            if (interval) clearInterval(interval);
            controller.close();
          }
        } catch (e) {
          console.error("IPs SSE build error", (e as Error).message);
        }
      }
      build();
      interval = setInterval(build, 5000);
    },
    cancel() {
      if (interval) clearInterval(interval);
    },
  });
  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream; charset=utf-8",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive",
      "Access-Control-Allow-Origin": "*",
    },
  });
}

const server = Bun.serve({
  port,
  async fetch(req: Request) {
    const url = new URL(req.url);

    // Add IP address
    if (url.pathname === "/ips/add" && req.method === "POST") {
      try {
        // Datastar sends FormData as JSON-like object with both lowercase & original casing
        const bodyText = await req.text();
        let ip = "";
        if (bodyText) {
          try {
            const parsed = JSON.parse(bodyText);
            if (typeof parsed.ip === "string") ip = parsed.ip.trim();
            else if (typeof parsed.IP === "string") ip = parsed.IP.trim();
          } catch {
            const params = new URLSearchParams(bodyText);
            const p = params.get("ip") || params.get("IP");
            if (p) ip = p.trim();
            else {
              const match = bodyText.match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
              if (match) ip = match[0];
            }
          }
        }
        ip = ip.trim();
        if (ip && !/^\d{1,3}(?:\.\d{1,3}){3}$/.test(ip)) ip = "";
        let ok = false;
        if (ip) ok = addIp(ip);
        if (ok) await persistIps();
        console.log("Add IP attempt", { raw: bodyText, parsedIp: ip, ok });
        const stream =
          dataStarPatchElementsString(
            <div id="add-ip-result" class="result">
              {ok ? `Added IP: ${ip}` : "Invalid or duplicate IP"}
            </div>,
          ) + dataStarPatchElementsString(<IpsUl ips={ipStore} />);
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
        });
      } catch (e) {
        const msg = (e as Error).message;
        const errorResultJsx = (
          <div id="add-ip-result" class="result">
            Error: {msg}
          </div>
        );
        return new Response(dataStarPatchElementsString(errorResultJsx), {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          status: 500,
        });
      }
    }

    // Remove IP (legacy body-based)
    if (url.pathname === "/ips/remove" && req.method === "POST") {
      try {
        const bodyText = await req.text();
        let ip = "";
        if (bodyText) {
          try {
            const parsed = JSON.parse(bodyText);
            if (typeof parsed.ip === "string") ip = parsed.ip.trim();
            else if (typeof parsed.IP === "string") ip = parsed.IP.trim();
          } catch {
            const params = new URLSearchParams(bodyText);
            const p = params.get("ip") || params.get("IP");
            if (p) ip = p.trim();
            else {
              const match = bodyText.match(/\b\d{1,3}(?:\.\d{1,3}){3}\b/);
              if (match) ip = match[0];
            }
          }
        }
        if (!ip) {
          const qp = url.searchParams.get("ip") || url.searchParams.get("IP");
          if (qp) ip = qp.trim();
        }
        ip = ip.trim();
        if (ip && !/^\d{1,3}(?:\.\d{1,3}){3}$/.test(ip)) ip = "";
        let ok = false;
        if (ip) ok = removeIp(ip);
        if (ok) await persistIps();
        console.log("Remove IP attempt", { raw: bodyText, parsedIp: ip, ok });
        const stream =
          dataStarPatchElementsString(
            <div id="add-ip-result" class="result">
              {ok
                ? "Removed IP: " + ip
                : ip
                  ? "IP not found"
                  : "No IP provided"}
            </div>,
          ) + dataStarPatchElementsString(<IpsUl ips={ipStore} />);
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
        });
      } catch (e) {
        const msg = (e as Error).message;
        return new Response(
          dataStarPatchElementsString(
            <div id="add-ip-result" class="result">
              Error: {msg}
            </div>,
          ),
          {
            headers: { "Content-Type": "text/event-stream; charset=utf-8" },
            status: 500,
          },
        );
      }
    }

    // Remove IP via path: POST /ips/remove/:ip
    if (url.pathname.startsWith("/ips/remove/") && req.method === "POST") {
      const parts = url.pathname.split("/").filter(Boolean); // ['ips','remove','ip']
      if (parts.length === 3) {
        const ip = parts[2].trim();
        let ok = false;
        if (/^\d{1,3}(?:\.\d{1,3}){3}$/.test(ip)) ok = removeIp(ip);
        if (ok) await persistIps();
        console.log("Remove IP path attempt", { ip, ok });
        const stream =
          dataStarPatchElementsString(
            <div id="add-ip-result" class="result">
              {ok ? "Removed IP: " + ip : "IP not found"}
            </div>,
          ) + dataStarPatchElementsString(<IpsUl ips={ipStore} />);
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
        });
      }
    }

    // IP list SSE
    if (url.pathname === "/ips/stream") return ipsSSE();

    // Sessions list SSE for given IP: /sessions/:ip/stream
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/stream")
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, 'stream']
      if (parts.length === 3) {
        const ip = parts[1];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        return sessionsSSE(ip);
      }
    }

    // Create session for IP: POST /sessions/:ip/create-session
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/create-session") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions','ip','create-session']
      if (parts.length === 3) {
        const ip = parts[1];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        try {
          const bodyText = await req.text();
          let title = "new session";
          if (bodyText) {
            try {
              const parsed = JSON.parse(bodyText);
              if (typeof parsed.title === "string" && parsed.title.trim())
                title = parsed.title.trim();
            } catch {
              /* ignore */
            }
          }
          const base = resolveBaseUrl(ip);
          const client = createOpencodeClient({ baseUrl: base });
          let created: any;
          try {
            created = await client.session.create({ body: { title } });
            console.log("SDK session.create raw:", created);
          } catch (e) {
            console.warn(
              "SDK create failed, trying raw endpoint:",
              (e as Error).message,
            );
            const rawRes = await fetch(`${base}/session`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title }),
            });
            if (!rawRes.ok) throw new Error(`Create ${rawRes.status}`);
            created = await rawRes.json();
          }
          let sessionId = (created as any)?.id;
          if (!sessionId) {
            const data = (created as any)?.data || created;
            sessionId = data?.id;
          }
          if (!sessionId || typeof sessionId !== "string")
            throw new Error(
              `Session creation returned invalid ID: ${JSON.stringify(created)}`,
            );
          // Inject into per-IP cache
          const entry = {
            id: sessionId,
            title: (created as any)?.title || title,
          };
          const now = Date.now();
          const existing = cachedSessionsByIp[ip];
          if (existing) {
            const ids = new Set(existing.list.map((s) => s.id));
            if (!ids.has(entry.id)) existing.list.unshift(entry);
            existing.fetchedAt = now;
          } else {
            cachedSessionsByIp[ip] = { list: [entry], fetchedAt: now };
          }

          const stream = dataStarPatchElementsString(
            <div
              id="create-session-result"
              class="result"
              data-init={`location.href='/sessions/${ip}/${entry.id}'`}
            >
              Created session:{" "}
              <a href={`/sessions/${ip}/${entry.id}`}>{entry.id}</a>
            </div>,
          );
          return new Response(stream, {
            headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          });
        } catch (e) {
          const msg = (e as Error).message;
          const errorJsx = (
            <div id="create-session-result" class="result">
              Error: {msg}
            </div>
          );
          return new Response(dataStarPatchElementsString(errorJsx), {
            headers: { "Content-Type": "text/event-stream; charset=utf-8" },
            status: 500,
          });
        }
      }
    }

    // Delete session for IP: POST /sessions/:ip/:sid/delete-session
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/delete-session") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'delete-session']
      if (parts.length === 4 && parts[3] === "delete-session") {
        const ip = parts[1];
        const sid = parts[2];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        let deletedOk = false;
        const base = resolveBaseUrl(ip);
        try {
          const client = createOpencodeClient({ baseUrl: base });
          try {
            const d = await (client as any).session.delete?.({
              path: { id: sid },
            });
            if (
              d &&
              (d.id === sid ||
                (d as any).data?.id === sid ||
                (d as any).ok ||
                (d as any).status === "ok")
            ) {
              deletedOk = true;
            }
          } catch (e) {
            console.warn("SDK delete failed", (e as Error).message);
          }
          if (!deletedOk) {
            try {
              const rawRes = await fetch(`${base}/session/${sid}`, {
                method: "DELETE",
              });
              if (rawRes.ok) deletedOk = true;
            } catch {}
          }
        } catch (e) {
          console.error("Delete session route error", (e as Error).message);
        }
        if (deletedOk) {
          const cache = cachedSessionsByIp[ip];
          if (cache && Array.isArray(cache.list)) {
            cache.list = cache.list.filter((s) => s.id !== sid);
          }
        }
        // Refresh list (best effort)
        await fetchSessionsFresh(ip).catch(() => null);
        const cache = cachedSessionsByIp[ip];
        const list = cache?.list || [];
        const stream =
          dataStarPatchElementsString(
            <div
              id="delete-session-result"
              class="result"
              data-init={deletedOk ? `location.href='/sessions/${ip}'` : ""}
            >
              {deletedOk
                ? `Deleted session: ${sid}`
                : "Delete failed or session not found"}
            </div>,
          ) +
          dataStarPatchElementsString(
            <div id="sessions-list">
              <SessionsUl
                ip={ip}
                sessions={list}
                summarizerId={await readSummarizerId()}
              />
            </div>,
          );
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          status: deletedOk ? 200 : 500,
        });
      }
    }
    // Share session for IP: POST /sessions/:ip/:sid/share-session
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/share-session") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'share-session']
      if (parts.length === 4 && parts[3] === "share-session") {
        const ip = parts[1];
        const sid = parts[2];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        let sharedOk = false;
        const base = resolveBaseUrl(ip);
        try {
          const client = createOpencodeClient({ baseUrl: base });
          try {
            const d = await (client as any).session.share?.({
              path: { id: sid },
            });
            if (
              d &&
              (d.id === sid ||
                (d as any).data?.id === sid ||
                (d as any).ok ||
                (d as any).status === "ok")
            ) {
              sharedOk = true;
            }
          } catch (e) {
            console.warn("SDK share failed", (e as Error).message);
          }
          if (!sharedOk) {
            try {
              const rawRes = await fetch(`${base}/session/${sid}/share`, {
                method: "POST",
              });
              if (rawRes.ok) sharedOk = true;
            } catch {}
          }
        } catch (e) {
          console.error("Share session route error", (e as Error).message);
        }
        let shareUrl: string | undefined;
        if (sharedOk) {
          try {
            const base = resolveBaseUrl(ip);
            const detailRes = await fetch(`${base}/session/${sid}`);
            if (detailRes.ok) {
              const json = await detailRes.json().catch(() => null);
              shareUrl =
                json?.share?.url ||
                json?.data?.share?.url ||
                json?.share_url ||
                json?.data?.share_url;
              if (typeof shareUrl === "string" && shareUrl) {
                try {
                  const aggKey = `${ip}::${sid}`;
                  const agg =
                    advancedAggregatedStateBySession[aggKey] ||
                    (advancedAggregatedStateBySession[aggKey] = {});
                  agg.shareUrl = shareUrl;
                } catch {}
              }
            }
          } catch {}
        }
        const stream = dataStarPatchElementsString(
          <div id="share-session-result" class="result">
            {sharedOk
              ? `Shared session: ${sid}${shareUrl ? " | " + shareUrl : ""}`
              : "Share failed or session not found"}
          </div>,
        );
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          status: sharedOk ? 200 : 500,
        });
      }
    }
    // Unshare session for IP: POST /sessions/:ip/:sid/unshare-session
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/unshare-session") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'unshare-session']
      if (parts.length === 4 && parts[3] === "unshare-session") {
        const ip = parts[1];
        const sid = parts[2];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        let unsharedOk = false;
        const base = resolveBaseUrl(ip);
        try {
          const client = createOpencodeClient({ baseUrl: base });
          try {
            const d = await (client as any).session.unshare?.({
              path: { id: sid },
            });
            if (
              d &&
              (d.id === sid ||
                (d as any).data?.id === sid ||
                (d as any).ok ||
                (d as any).status === "ok")
            ) {
              unsharedOk = true;
            }
          } catch (e) {
            console.warn("SDK unshare failed", (e as Error).message);
          }
          if (!unsharedOk) {
            try {
              const rawRes = await fetch(`${base}/session/${sid}/unshare`, {
                method: "POST",
              });
              if (rawRes.ok) unsharedOk = true;
            } catch {}
          }
        } catch (e) {
          console.error("Unshare session route error", (e as Error).message);
        }
        const stream = dataStarPatchElementsString(
          <div id="share-session-result" class="result">
            {unsharedOk
              ? `Unshared session: ${sid}`
              : "Unshare failed or session not found"}
          </div>,
        );
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          status: unsharedOk ? 200 : 500,
        });
      }
    }
    // Clear all sessions for IP: POST /sessions/:ip/clear-sessions
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/clear-sessions") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions','ip','clear-sessions']
      if (parts.length === 3 && parts[2] === "clear-sessions") {
        const ip = parts[1];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        let deletedCount = 0;
        let total = 0;
        const base = resolveBaseUrl(ip);
        try {
          // Fetch latest list to ensure we attempt all existing sessions
          const list = await fetchSessionsFresh(ip);
          const ids = list
            .map((s) => s.id)
            .filter((id) => typeof id === "string" && id.trim());
          total = ids.length;
          for (const sid of ids) {
            let deletedOk = false;
            try {
              const client = createOpencodeClient({ baseUrl: base });
              try {
                const d = await (client as any).session.delete?.({
                  path: { id: sid },
                });
                if (
                  d &&
                  (d.id === sid ||
                    (d as any).data?.id === sid ||
                    (d as any).ok ||
                    (d as any).status === "ok")
                ) {
                  deletedOk = true;
                }
              } catch (e) {
                console.warn("SDK delete failed (bulk)", (e as Error).message);
              }
              if (!deletedOk) {
                try {
                  const rawRes = await fetch(`${base}/session/${sid}`, {
                    method: "DELETE",
                  });
                  if (rawRes.ok) deletedOk = true;
                } catch {}
              }
            } catch (e) {
              console.error(
                "Bulk delete session error",
                sid,
                (e as Error).message,
              );
            }
            if (deletedOk) deletedCount++;
          }
        } catch (e) {
          console.error("Clear sessions route error", (e as Error).message);
        }
        // Reset cache for IP (will be repopulated on next fetch)
        const cache = cachedSessionsByIp[ip];
        if (cache) cache.list = [];
        // Best-effort refresh (in case some deletions failed and we want fresh remaining list)
        await fetchSessionsFresh(ip).catch(() => null);
        const afterCache = cachedSessionsByIp[ip];
        const remainingList = afterCache?.list || [];
        const stream =
          dataStarPatchElementsString(
            <div id="delete-session-result" class="result">
              {`Cleared sessions: ${deletedCount} / ${total}`}
            </div>,
          ) +
          dataStarPatchElementsString(
            <div id="sessions-list">
              <SessionsUl
                ip={ip}
                sessions={remainingList}
                summarizerId={await readSummarizerId()}
              />
            </div>,
          );
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          status: 200,
        });
      }
    }
    // Deprecated messages SSE endpoint removed; use /sessions/:ip/:sid/advanced/events/stream instead.

    // Advanced raw JSON endpoint removed (manual fetch disabled)

    // Advanced SDK JSON: GET /sessions/:ip/:sid/advanced/sdk-json
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/advanced/sdk-json") &&
      req.method === "GET"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'advanced','sdk-json']
      if (
        parts.length === 5 &&
        parts[3] === "advanced" &&
        parts[4] === "sdk-json"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        const base = resolveBaseUrl(ip);
        let sdkDetail: any = null;
        let sdkList: any = null;
        let rawDetail: any = null;
        const attempts: any[] = [];
        try {
          const client = createOpencodeClient({ baseUrl: base });
          // Attempt multiple shapes for session.get
          async function tryGet(label: string, fn: () => Promise<any>) {
            try {
              const val = await fn();
              if (val) {
                const directId = (val as any).id;
                const nestedId = (val as any).data?.id;
                const okMatch = directId === sid || nestedId === sid;
                attempts.push({
                  label,
                  ok: okMatch,
                  keys: Object.keys(val || {}),
                  directId,
                  nestedId,
                });
                if (okMatch && !sdkDetail) sdkDetail = val;
              } else {
                attempts.push({ label, ok: false, value: val });
              }
            } catch (e) {
              attempts.push({ label, ok: false, error: (e as Error).message });
            }
          }
          await tryGet("params.id", () =>
            (client as any).session.get?.({ path: { id: sid } }),
          );
          if (!sdkDetail)
            await tryGet("params.session_id", () =>
              (client as any).session.get?.({ params: { session_id: sid } }),
            );
          if (!sdkDetail)
            await tryGet("body.id", () =>
              (client as any).session.get?.({ body: { id: sid } }),
            );
          if (!sdkDetail)
            await tryGet("body.session_id", () =>
              (client as any).session.get?.({ body: { session_id: sid } }),
            );
          if (!sdkDetail)
            await tryGet("direct.id", () =>
              (client as any).session.get?.({ id: sid }),
            );
          // Raw fetch fallback for comparison if still missing
          if (!sdkDetail) {
            try {
              const rawRes = await fetch(`${base}/session/${sid}`);
              if (rawRes.ok) rawDetail = await rawRes.json().catch(() => null);
              attempts.push({
                label: "raw.fetch",
                ok: !!rawDetail,
                rawStatus: rawRes.status,
              });
            } catch (e) {
              attempts.push({
                label: "raw.fetch",
                ok: false,
                error: (e as Error).message,
              });
            }
          }
          try {
            sdkList = await client.session.list().catch((e: any) => {
              console.warn(
                "SDK session.list error",
                (e && e.message) || String(e),
              );
              return null;
            });
          } catch {}
        } catch (e) {
          console.warn("SDK init error", (e as Error).message);
        }
        const payload = {
          sdkDetail,
          sdkListSummary: Array.isArray(sdkList)
            ? sdkList.map((s) => ({ id: s.id, title: s.title }))
            : sdkList,
          attempts,
          rawDetail,
        };
        const jsonText = JSON.stringify(payload, null, 2);
        // Pass raw JSON; JSX will escape inside <textarea>
        const sdkJsonJsx = <AdvancedSdkJson jsonText={jsonText} />;
        return new Response(dataStarPatchElementsString(sdkJsonJsx), {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
        });
      }
    }

    // Advanced events SSE: /sessions/:ip/:sid/advanced/events/stream (batched, truncation, retry)
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/advanced/events/stream")
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'advanced','events','stream']
      if (
        parts.length === 6 &&
        parts[3] === "advanced" &&
        parts[4] === "events" &&
        parts[5] === "stream"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        // Buffer of last raw event lines (JSON strings)
        const eventBuffer: string[] = [];
        const attempts: any[] = [];
        const MAX_BUFFER = 100;
        const MAX_FIELD_LEN = 500; // truncate oversize data field values
        let lastPatchTs = 0;
        let pendingPatch = false;
        const PATCH_INTERVAL_MS = 400; // batch frequent events
        let upstreamController: AbortController | undefined;
        let upstreamClosed = false;
        let closed = false;
        const scheduledTimeouts = new Set<ReturnType<typeof setTimeout>>();
        // Candidate upstream SSE endpoints to probe relative to base
        const base = resolveBaseUrl(ip);
        const candidates = [
          `${base}/events`,
          `${base}/event`,
          `${base}/session/${sid}/events`,
          `${base}/session/${sid}/event`,
          `${base}/session/${sid}/stream`,
        ];
        // Aggregated state (derived from upstream + synthetic events)
        // Persist across SSE reconnects using global map keyed by ip::sessionId
        const aggKey = `${ip}::${sid}`;
        // Global store defined above caches; create if missing
        if (!advancedAggregatedStateBySession[aggKey]) {
          advancedAggregatedStateBySession[aggKey] = {
            meta: { ip, sessionId: sid, createdAt: Date.now() },
            counts: {
              totalEvents: 0,
              upstreamEvents: 0,
              syntheticMessageUpdates: 0,
            },
            lastMessage: { role: "", text: "" }, // last single message snapshot
            lastMessages: [] as any[], // last <=10 full messages (role,text,parts)

            messageCount: 0,
            parts: {},
            lastTypes: [] as string[],
            lastEventTs: 0,
            reconnects: 0,
            summary: "",
            actionFlag: false,
          };
        } else {
          // Mark reconnect for visibility
          advancedAggregatedStateBySession[aggKey].reconnects =
            (advancedAggregatedStateBySession[aggKey].reconnects || 0) + 1;
        }
        const aggregatedState = advancedAggregatedStateBySession[aggKey];
        const MAX_STATE_JSON_LEN = 4000;
        function applyEventToState(obj: any) {
          aggregatedState.counts.totalEvents++;
          aggregatedState.lastEventTs = Date.now();
          const type = (obj?.data && obj.data.type) || obj?.event || "";
          if (typeof type === "string" && type) {
            aggregatedState.lastTypes.push(type);
            if (aggregatedState.lastTypes.length > 50)
              aggregatedState.lastTypes.splice(
                0,
                aggregatedState.lastTypes.length - 50,
              );
          }
          // Message part updates
          if (
            obj?.data &&
            typeof obj.data === "object" &&
            !Array.isArray(obj.data)
          ) {
            try {
              if (type === "message.part.updated") {
                const part =
                  (obj.data as any).part || (obj.data as any).data?.part;
                if (part && typeof part === "object") {
                  const pid = part.id || part.part_id || part.partId;
                  if (pid) {
                    aggregatedState.parts[pid] = {
                      type: part.type,
                      text:
                        typeof part.text === "string"
                          ? part.text.substring(0, 300)
                          : "",
                      updatedAt: Date.now(),
                    };
                    // Prune parts map if too large (keep last 200 by updatedAt)
                    const keys = Object.keys(aggregatedState.parts);
                    if (keys.length > 200) {
                      const sorted = keys.sort(
                        (a, b) =>
                          aggregatedState.parts[a].updatedAt -
                          aggregatedState.parts[b].updatedAt,
                      );
                      const remove = sorted.slice(0, keys.length - 200);
                      for (const k of remove) delete aggregatedState.parts[k];
                    }
                  }
                }
              }
              if (type === "session.message.update") {
                aggregatedState.counts.syntheticMessageUpdates++;
                if (typeof obj.data.count === "number")
                  aggregatedState.messageCount = obj.data.count;
                if (typeof obj.data.role === "string")
                  aggregatedState.lastMessage.role = obj.data.role;
                if (typeof obj.data.text === "string")
                  aggregatedState.lastMessage.text = obj.data.text.substring(
                    0,
                    600,
                  );
              }
            } catch {}
          }
        }
        function serializeAggregatedState() {
          try {
            const json = JSON.stringify(aggregatedState, null, 2);
            return json.length > MAX_STATE_JSON_LEN
              ? json.substring(0, MAX_STATE_JSON_LEN) + "..."
              : json;
          } catch {
            return "";
          }
        }
        // Helper to push patch of AdvancedEvents fragment
        function enqueuePatch(controller: ReadableStreamDefaultController) {
          if (closed) return; // guard after closure
          try {
            const stateJson = serializeAggregatedState();
            const statusJsx = (
              <div
                id="messages-status"
                class="status"
              >{`Updated ${new Date().toLocaleTimeString()}`}</div>
            );
            const jsx = (
              <AdvancedEvents
                events={eventBuffer}
                attempts={attempts}
                stateJson={stateJson}
              />
            );
            // Recent messages fragment from aggregated state
            const recentMsgs = Array.isArray(aggregatedState.lastMessages)
              ? aggregatedState.lastMessages
              : [];
            const summaryText = aggregatedState.summary || undefined;
            const actionFlag = aggregatedState.actionFlag || false;
            const totalCount =
              aggregatedState.messageCount || recentMsgs.length;
            let recentJsx = (
              <AdvancedRecentMessages
                messages={recentMsgs as any}
                summaryText={summaryText}
                actionFlag={actionFlag}
                totalCount={totalCount}
              />
            );
            if (summaryText === "(send failed: retry)") {
              recentJsx = (
                <div id="messages-list">
                  <div style="font-size:.7rem;opacity:.6;margin-bottom:4px">
                    recent messages (events-derived)
                  </div>
                  <MessageItems messages={recentMsgs as any} />
                  <div
                    class="messages-summary"
                    style="opacity:.75;margin-top:4px"
                  >
                    send failed
                    <form
                      data-on:submit={`@post('/sessions/${ip}/${sid}/message/retry'); $messageText = ''`}
                      style="display:inline;margin-left:8px"
                    >
                      <button type="submit" style="font-size:.65rem">
                        retry last
                      </button>
                    </form>
                  </div>
                </div>
              );
            }
            controller.enqueue(
              new TextEncoder().encode(dataStarPatchElementsString(statusJsx)),
            );
            controller.enqueue(
              new TextEncoder().encode(dataStarPatchElementsString(recentJsx)),
            );
            controller.enqueue(
              new TextEncoder().encode(dataStarPatchElementsString(jsx)),
            );
            controller.enqueue(
              new TextEncoder().encode(renderAutoScrollScriptEvent()),
            );
            lastPatchTs = Date.now();
            pendingPatch = false;
          } catch (e) {
            // If controller is closed, mark closed to suppress future patches
            console.error(
              "Advanced events enqueue error",
              (e as Error).message,
            );
          }
        }
        // Open first successful candidate
        async function openFirst(controller: ReadableStreamDefaultController) {
          let candidateIndex = 0;
          async function tryNext() {
            if (candidateIndex >= candidates.length) return; // exhausted
            const urlStr = candidates[candidateIndex++];
            const attempt: any = { url: urlStr, ok: false };
            attempts.push(attempt);
            let startTs = Date.now();
            try {
              upstreamController = new AbortController();
              const res = await fetch(urlStr, {
                signal: upstreamController.signal,
              });
              attempt.status = res.status;
              attempt.headers = Array.from(res.headers.keys());
              if (!res.ok) {
                attempt.error = `status ${res.status}`;
                return tryNext();
              }
              const contentType = res.headers.get("content-type") || "";
              if (!/text\/event-stream/i.test(contentType)) {
                attempt.error = "not event-stream";
                return tryNext();
              }
              attempt.ok = true;
              const reader = res.body?.getReader();
              if (!reader) {
                attempt.error = "no body reader";
                return tryNext();
              }
              (async () => {
                const decoder = new TextDecoder();
                let buffered = "";
                let eventCount = 0;
                try {
                  while (true) {
                    const chunk = await reader.read();
                    if (chunk.done) break;
                    buffered += decoder.decode(chunk.value, { stream: true });
                    let idx;
                    while ((idx = buffered.indexOf("\n\n")) !== -1) {
                      const rawEvent = buffered.slice(0, idx).trim();
                      buffered = buffered.slice(idx + 2);
                      if (!rawEvent) continue;
                      const lines = rawEvent.split(/\n+/);
                      const obj: any = { raw: rawEvent };
                      for (const line of lines) {
                        const m = line.match(/^(event|data|id|retry):\s*(.*)$/);
                        if (m) {
                          const key = m[1];
                          const val = m[2];
                          if (key === "data") {
                            let parsed: any = null;
                            try {
                              parsed = JSON.parse(val);
                            } catch {}
                            obj.data = parsed || val;
                          } else obj[key] = val;
                        }
                      }
                      // Truncate oversize string fields
                      if (
                        typeof obj.data === "string" &&
                        obj.data.length > MAX_FIELD_LEN
                      )
                        obj.data = obj.data.substring(0, MAX_FIELD_LEN) + "...";
                      if (
                        typeof obj.raw === "string" &&
                        obj.raw.length > MAX_FIELD_LEN
                      )
                        obj.raw = obj.raw.substring(0, MAX_FIELD_LEN) + "...";
                      applyEventToState(obj);
                      aggregatedState.counts.upstreamEvents++;
                      const jsonLine = JSON.stringify(obj);
                      eventBuffer.push(jsonLine);
                      eventCount++;
                      if (eventBuffer.length > MAX_BUFFER)
                        eventBuffer.splice(0, eventBuffer.length - MAX_BUFFER);
                      if (!pendingPatch) {
                        pendingPatch = true;
                        const now = Date.now();
                        const dueIn = Math.max(
                          0,
                          PATCH_INTERVAL_MS - (now - lastPatchTs),
                        );
                        const to = setTimeout(() => {
                          scheduledTimeouts.delete(to);
                          enqueuePatch(controller);
                        }, dueIn);
                        scheduledTimeouts.add(to);
                      }
                    }
                  }
                } catch (e) {
                  if ((e as any)?.name === "AbortError") {
                    console.warn("Upstream SSE aborted");
                  } else
                    console.error(
                      "Upstream SSE read error",
                      (e as Error).message,
                    );
                } finally {
                  upstreamClosed = true;
                  attempts.push({
                    url: urlStr,
                    closed: true,
                    events: eventCount,
                    durationMs: Date.now() - startTs,
                  });
                  // Retry next candidate if very few events and time short (<2s, <3 events)
                  if (eventCount < 3 && Date.now() - startTs < 2000) {
                    tryNext();
                  }
                  enqueuePatch(controller);
                }
              })();
            } catch (e) {
              attempt.error = (e as Error).message;
              return tryNext();
            }
            enqueuePatch(controller); // patch after starting attempt
          }
          await tryNext();
        }

        let heartbeat: ReturnType<typeof setInterval> | undefined;
        let messageInterval: ReturnType<typeof setInterval> | undefined;
        const stream = new ReadableStream({
          async start(controller) {
            const startTs = Date.now();
            await openFirst(controller);
            // Periodically fetch new messages for this session and append synthetic SSE entries.
            // This augments upstream generic events so Advanced view always reflects message flow.
            let lastMessageCount = 0;
            async function pollMessages() {
              try {
                const msgs = await fetchMessages(ip, sid);
                const count = msgs.length;
                // Update aggregated recent messages (always capture even if count unchanged to allow external inspection)
                const trimmed = count > 10 ? msgs.slice(-10) : msgs;
                aggregatedState.lastMessages = trimmed.map((m) => ({
                  role: m.role,
                  text: m.text,
                  parts: m.parts,
                }));
                aggregatedState.messageCount = count;
                // Summary / action logic (mirrors messages SSE logic but integrated here)
                const cacheKey = `${ip}::${sid}`;
                const recentForHash = msgs.slice(-3).map((m: any) => ({
                  role: m.role || "message",
                  text: (m.parts?.[0]?.text || m.text || "")
                    .replace(/\s+/g, " ")
                    .trim(),
                }));
                const cached = summaryCacheBySession[cacheKey];
                const { hash: recentHash, reuse } = shouldReuseSummary(
                  cached?.messageHash,
                  recentForHash,
                );
                let summaryText = "(no recent messages)";
                if (count === 0) {
                  summaryText = "(no recent messages)";
                } else if (reuse && cached) {
                  summaryText = cached.summary;
                } else {
                  summaryText = "...";
                  // Debounce summary recompute only when last role is assistant
                  const lastRole = msgs[msgs.length - 1]?.role || "";
                  const shouldSummarize = lastRole === "assistant";
                  if (shouldSummarize && !inFlightSummary[cacheKey]) {
                    if (summaryDebounceTimers[cacheKey]) {
                      clearTimeout(summaryDebounceTimers[cacheKey]);
                      delete summaryDebounceTimers[cacheKey];
                    }
                    summaryDebounceTimers[cacheKey] = setTimeout(() => {
                      delete summaryDebounceTimers[cacheKey];
                      if (inFlightSummary[cacheKey]) return;
                      inFlightSummary[cacheKey] = true;
                      (async () => {
                        try {
                          const remoteBase = resolveBaseUrl(ip);
                          const { summarizeMessages } = await import(
                            "./src/oc-client"
                          );
                          const summ = await summarizeMessages(
                            remoteBase,
                            recentForHash,
                            sid,
                          );
                          if (summ.ok) {
                            summaryCacheBySession[cacheKey] = {
                              messageHash: recentHash,
                              summary: summ.summary || "(empty summary)",
                              action: summ.action,
                              cachedAt: Date.now(),
                            };
                          } else {
                            summaryCacheBySession[cacheKey] = {
                              messageHash: recentHash,
                              summary: "(summary failed)",
                              action: false,
                              cachedAt: Date.now(),
                            };
                          }
                        } catch (e) {
                          summaryCacheBySession[cacheKey] = {
                            messageHash: recentHash,
                            summary: "(summary failed)",
                            action: false,
                            cachedAt: Date.now(),
                          };
                        } finally {
                          const entry = summaryCacheBySession[cacheKey];
                          aggregatedState.summary = entry.summary;
                          aggregatedState.actionFlag = entry.action;
                          delete inFlightSummary[cacheKey];
                          if (!pendingPatch) {
                            pendingPatch = true;
                            const now2 = Date.now();
                            const dueIn2 = Math.max(
                              0,
                              PATCH_INTERVAL_MS - (now2 - lastPatchTs),
                            );
                            const to2 = setTimeout(() => {
                              scheduledTimeouts.delete(to2);
                              enqueuePatch(controller);
                            }, dueIn2);
                            scheduledTimeouts.add(to2);
                          }
                        }
                      })();
                    }, SUMMARY_DEBOUNCE_MS);
                  }
                }
                const previousSummary = aggregatedState.summary;
                // Determine action flag from cached or summary text
                const cacheAfter = summaryCacheBySession[cacheKey];
                const actionFlag = cacheAfter
                  ? cacheAfter.action
                  : /\|\s*action\s*=\s*yes/i.test(summaryText);
                aggregatedState.summary = summaryText;
                aggregatedState.actionFlag = actionFlag;
                // If summary updated (reuse or placeholder change) schedule patch even if count unchanged
                if (previousSummary !== summaryText && !pendingPatch) {
                  pendingPatch = true;
                  const now3 = Date.now();
                  const dueIn3 = Math.max(
                    0,
                    PATCH_INTERVAL_MS - (now3 - lastPatchTs),
                  );
                  const to3 = setTimeout(() => {
                    scheduledTimeouts.delete(to3);
                    enqueuePatch(controller);
                  }, dueIn3);
                  scheduledTimeouts.add(to3);
                }
                if (count !== lastMessageCount) {
                  // Only append synthetic event when count changes.
                  const latest = msgs[msgs.length - 1];
                  const payload: any = {
                    type: "session.message.update",
                    count,
                    role: latest?.role,
                    text: latest?.texts
                      ? latest.texts.slice(-1)[0]
                      : latest?.text || "",
                  };
                  const synthetic = {
                    raw: "data: " + JSON.stringify(payload),
                    data: payload,
                  };
                  applyEventToState(synthetic);
                  const jsonLine = JSON.stringify(synthetic);
                  eventBuffer.push(jsonLine);
                  if (eventBuffer.length > MAX_BUFFER)
                    eventBuffer.splice(0, eventBuffer.length - MAX_BUFFER);
                  lastMessageCount = count;
                  if (!pendingPatch) {
                    pendingPatch = true;
                    const now = Date.now();
                    const dueIn = Math.max(
                      0,
                      PATCH_INTERVAL_MS - (now - lastPatchTs),
                    );
                    const to = setTimeout(() => {
                      scheduledTimeouts.delete(to);
                      enqueuePatch(controller);
                    }, dueIn);
                    scheduledTimeouts.add(to);
                  }
                }
              } catch (e) {
                attempts.push({
                  notice: "message poll error",
                  error: (e as Error).message,
                });
                if (!pendingPatch) enqueuePatch(controller);
              }
            }
            // Initial poll and interval every 2s (align with messages SSE cadence)
            await pollMessages();
            messageInterval = setInterval(pollMessages, 2000);
            // No-events timeout notice
            setTimeout(() => {
              if (eventBuffer.length === 0) {
                attempts.push({
                  notice: "no events received yet",
                  sinceMs: Date.now() - startTs,
                });
                enqueuePatch(controller);
              }
            }, 5000);
            // Heartbeat to update status if upstream closed without new events
            heartbeat = setInterval(() => {
              if (upstreamClosed) {
                enqueuePatch(controller);
              }
            }, 5000);
          },
          cancel() {
            closed = true;
            if (heartbeat) clearInterval(heartbeat);
            if (upstreamController) upstreamController.abort();
            if (messageInterval) clearInterval(messageInterval);
            for (const to of scheduledTimeouts) clearTimeout(to);
            scheduledTimeouts.clear();
          },
        });
        return new Response(stream, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8",
            "Cache-Control": "no-cache, no-transform",
            Connection: "keep-alive",
            "Access-Control-Allow-Origin": "*",
          },
        });
      }
    }

    // Advanced session SSE: /sessions/:ip/:sid/advanced/stream
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/advanced/stream")
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'advanced','stream']
      if (
        parts.length === 5 &&
        parts[3] === "advanced" &&
        parts[4] === "stream"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        let sessionTitle = "";
        try {
          const cache = cachedSessionsByIp[ip];
          if (cache && Array.isArray(cache.list)) {
            const found = cache.list.find((s) => s.id === sid);
            if (found && typeof found.title === "string")
              sessionTitle = found.title.trim();
          }
        } catch {}
        let interval: ReturnType<typeof setInterval> | undefined;
        const stream = new ReadableStream({
          async start(controller) {
            async function push() {
              try {
                const cacheKey = `${ip}::${sid}`;
                let approxCount = 0;
                const cachedCount = messageCountCache[cacheKey];
                const fresh =
                  cachedCount &&
                  Date.now() - cachedCount.updatedAt <= MESSAGE_COUNT_FRESH_MS;
                if (fresh) {
                  approxCount = cachedCount.count;
                } else {
                  // Fallback: fetch messages for count only (reuse existing function)
                  const msgs = await fetchMessages(ip, sid);
                  approxCount = msgs.length;
                  messageCountCache[cacheKey] = {
                    count: approxCount,
                    updatedAt: Date.now(),
                  };
                }
                const displayTitle = sessionTitle || sid;
                const statusJsx = (
                  <div id="advanced-status" class="status">
                    {`Updated ${new Date().toLocaleTimeString()}`}
                  </div>
                );
                const shareUrl = await deriveShareUrlForSession(ip, sid);
                const infoWrapperJsx = (
                  <AdvancedInfo
                    title={displayTitle}
                    approxCount={approxCount}
                    shareUrl={shareUrl}
                  />
                );
                controller.enqueue(
                  new TextEncoder().encode(
                    dataStarPatchElementsString(statusJsx),
                  ),
                );
                controller.enqueue(
                  new TextEncoder().encode(
                    dataStarPatchElementsString(infoWrapperJsx),
                  ),
                );
              } catch (e) {
                console.error("Advanced SSE push error", (e as Error).message);
              }
            }
            await push();
            interval = setInterval(push, 5000);
          },
          cancel() {
            if (interval) clearInterval(interval);
          },
        });
        return new Response(stream, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8",
            "Cache-Control": "no-cache, no-transform",
            Connection: "keep-alive",
            "Access-Control-Allow-Origin": "*",
          },
        });
      }
    }

    // Send message: POST /sessions/:ip/:sid/message
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/message") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'message']
      if (parts.length === 4 && parts[3] === "message") {
        const ip = parts[1];
        const sid = parts[2];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        try {
          const bodyText = await req.text();
          let text = "";
          if (bodyText) {
            try {
              const parsed = JSON.parse(bodyText);
              if (
                typeof parsed.messageText === "string" &&
                parsed.messageText.trim()
              )
                text = parsed.messageText.trim();
              else if (
                typeof parsed.messagetext === "string" &&
                parsed.messagetext.trim()
              )
                text = parsed.messagetext.trim();
              else if (typeof parsed.text === "string" && parsed.text.trim())
                text = parsed.text.trim();
              else if (Array.isArray(parsed.parts)) {
                const part = parsed.parts.find((p: any) => p?.type === "text");
                if (part && typeof part.text === "string" && part.text.trim())
                  text = part.text.trim();
              }
            } catch {
              /* ignore */
            }
          }
          if (!text)
            return new Response(
              dataStarPatchElementsString(
                <div id="session-message-result" class="result">
                  No text
                </div>,
              ),
              {
                headers: { "Content-Type": "text/event-stream; charset=utf-8" },
              },
            );
          // First message injection logic
          const sessionKey = sid;
          let injected = false;
          try {
            if (
              !firstMessageSeen.has(sessionKey) &&
              !inFlightFirstMessage[sessionKey]
            ) {
              inFlightFirstMessage[sessionKey] = true;
              // Remote check to avoid misfire if messages already exist
              let existingCount = 0;
              try {
                const existing = await listMessages(
                  resolveBaseUrl(ip),
                  sid,
                ).catch(() => []);
                existingCount = existing.length;
              } catch {}
              if (existingCount === 0) {
                // Prepend system-style instruction
                text = FIRST_MESSAGE_INSTRUCTION + "\n\n" + text;
                injected = true;
              }
              firstMessageSeen.add(sessionKey);
              delete inFlightFirstMessage[sessionKey];
            }
          } catch {
            delete inFlightFirstMessage[sessionKey];
          }
          console.log("Message send start", { ip, sid, text, injected });
          // Queue-based send with automatic retry of last failed job (once) before new text
          const queueKey = `${ip}::${sid}`;
          const existingJobs =
            queueJobsBySession[queueKey] || (queueJobsBySession[queueKey] = []);
          // Find most recent failed job eligible for auto-retry (not yet autoRetried)
          const failedForRetry = [...existingJobs]
            .reverse()
            .find((j) => j.status === "failed" && !j.autoRetried);
          if (failedForRetry) {
            const retryJob: QueuedMessageJob = {
              ip,
              sid,
              text: failedForRetry.text,
              createdAt: Date.now(),
              id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
              attempts: 0,
              status: "pending",
              autoRetried: true,
            };
            messageSendQueue.push(retryJob);
            existingJobs.push(retryJob);
            failedForRetry.autoRetried = true; // mark original failed so we do only one auto retry
            // Reset summary to placeholder if previously in failed state
            const aggKey = `${ip}::${sid}`;
            const agg = advancedAggregatedStateBySession[aggKey];
            if (agg && agg.summary === "(send failed: retry)")
              agg.summary = "...";
            console.log("Auto-retry queued before new message", {
              queueKey,
              retryId: retryJob.id,
            });
          }
          // Now enqueue new message job
          const job: QueuedMessageJob = {
            ip,
            sid,
            text,
            createdAt: Date.now(),
            id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
            attempts: 0,
            status: "pending",
          };
          messageSendQueue.push(job);
          existingJobs.push(job);
          console.log("Message queued", {
            queueKey,
            length: messageSendQueue.length,
          });
          // Trigger background processing immediately (non-blocking)
          processMessageQueue().catch(() => {});
          const replyJsx = (
            <div id="session-message-result" class="result">
              Queued (jobs: {queueJobsBySession[queueKey].length})
            </div>
          );
          return new Response(dataStarPatchElementsString(replyJsx), {
            headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          });
        } catch (e) {
          console.error("Message route error", (e as Error).message);
          const msg = (e as Error).message;
          const errorJsx = (
            <div id="session-message-result" class="result">
              Error: {msg}
            </div>
          );
          return new Response(dataStarPatchElementsString(errorJsx), {
            headers: { "Content-Type": "text/event-stream; charset=utf-8" },
            status: 500,
          });
        }
      }
    }

    // Retry last failed queued message: POST /sessions/:ip/:sid/message/retry
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/message/retry") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'message','retry']
      if (
        parts.length === 5 &&
        parts[3] === "message" &&
        parts[4] === "retry"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!ipStore.includes(ip))
          return new Response("Unknown IP", { status: 404 });
        const queueKey = `${ip}::${sid}`;
        const jobs = queueJobsBySession[queueKey] || [];
        // Find most recent failed job
        const failed = [...jobs].reverse().find((j) => j.status === "failed");
        if (!failed) {
          const noFailJsx = (
            <div id="session-message-result" class="result">
              No failed job
            </div>
          );
          return new Response(dataStarPatchElementsString(noFailJsx), {
            headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          });
        }
        // Requeue with same text new id
        const newJob: QueuedMessageJob = {
          ip,
          sid,
          text: failed.text,
          createdAt: Date.now(),
          id: `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,
          attempts: 0,
          status: "pending",
        };
        messageSendQueue.push(newJob);
        jobs.push(newJob);
        processMessageQueue().catch(() => {});
        // Update aggregated state summary placeholder
        const aggKey = `${ip}::${sid}`;
        const agg = advancedAggregatedStateBySession[aggKey];
        if (agg) agg.summary = "...";
        const retryJsx = (
          <div id="session-message-result" class="result">
            Retry queued
          </div>
        );
        return new Response(dataStarPatchElementsString(retryJsx), {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
        });
      }
    }

    // Session detail page: GET /sessions/:ip/:sid
    if (url.pathname.startsWith("/sessions/")) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, maybe 'advanced']
      if (
        parts.length === 3 &&
        req.method === "GET" &&
        parts[0] === "sessions"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!ipStore.includes(ip)) return Response.redirect("/", 302);
        // Validate session exists (best effort)
        try {
          const base = resolveBaseUrl(ip);
          const client = createOpencodeClient({ baseUrl: base });
          let exists = false;
          try {
            const detail = await (client as any).session.get?.({
              path: { id: sid },
            });
            if (detail && detail.id === sid) exists = true;
          } catch {
            /* ignore */
          }
          if (!exists) {
            try {
              const rawRes = await fetch(`${base}/session/${sid}`);
              if (rawRes.ok) {
                const rawJson = await rawRes.json().catch(() => null);
                if (rawJson && rawJson.id === sid) exists = true;
              }
            } catch {
              /* ignore */
            }
          }
          if (!exists) {
            try {
              const list = await client.session.list();
              exists =
                Array.isArray(list) && list.some((s: any) => s.id === sid);
            } catch {
              /* ignore */
            }
          }
          if (!exists)
            return Response.redirect(
              `/sessions/${encodeURIComponent(ip)}`,
              302,
            );
        } catch {
          /* ignore */
        }
        let sessionTitle = "";
        try {
          const base = resolveBaseUrl(ip);
          const cache = cachedSessionsByIp[ip];
          if (cache && Array.isArray(cache.list)) {
            const found = cache.list.find((s) => s.id === sid);
            if (found && typeof found.title === "string")
              sessionTitle = found.title.trim();
          }
          if (!sessionTitle) {
            try {
              const client2 = createOpencodeClient({ baseUrl: base });
              const list2 = await client2.session.list().catch(() => []);
              if (Array.isArray(list2)) {
                const found2 = list2.find((s: any) => s && s.id === sid);
                if (found2) {
                  const t =
                    (found2 as any).title || (found2 as any).data?.title;
                  if (typeof t === "string" && t.trim())
                    sessionTitle = t.trim();
                }
              }
            } catch {}
          }
          if (!sessionTitle) {
            try {
              const rawRes2 = await fetch(`${base}/session/${sid}`);
              if (rawRes2.ok) {
                const rawJson2 = await rawRes2.json().catch(() => null);
                if (rawJson2 && rawJson2.id === sid) {
                  const t =
                    (rawJson2 as any).title || (rawJson2 as any).data?.title;
                  if (typeof t === "string" && t.trim())
                    sessionTitle = t.trim();
                }
              }
            } catch {}
          }
        } catch {}
        const page = renderSessionDetailPage({
          ip,
          sessionId: sid,
          sessionTitle,
        });
        return new Response(page, {
          headers: { "Content-Type": "text/html; charset=utf-8" },
        });
      }
      // Advanced session page: GET /sessions/:ip/:sid/advanced
      if (
        parts.length === 4 &&
        req.method === "GET" &&
        parts[0] === "sessions" &&
        parts[3] === "advanced"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!ipStore.includes(ip)) return Response.redirect("/", 302);
        // Reuse title lookup from detail page (best effort)
        let sessionTitle = "";
        try {
          const cache = cachedSessionsByIp[ip];
          if (cache && Array.isArray(cache.list)) {
            const found = cache.list.find((s) => s.id === sid);
            if (found && typeof found.title === "string")
              sessionTitle = found.title.trim();
          }
        } catch {}
        const page = renderSessionAdvancedPage({
          ip,
          sessionId: sid,
          sessionTitle,
        });
        return new Response(page, {
          headers: { "Content-Type": "text/html; charset=utf-8" },
        });
      }
      // Sessions list page: GET /sessions/:ip
      if (
        parts.length === 2 &&
        req.method === "GET" &&
        parts[0] === "sessions"
      ) {
        const ip = parts[1];
        if (!ipStore.includes(ip)) return Response.redirect("/", 302);
        const page = renderSessionsListPage({ ip });
        return new Response(page, {
          headers: { "Content-Type": "text/html; charset=utf-8" },
        });
      }
    }

    // Home page
    if (url.pathname === "/" || url.pathname === "/index.html") {
      return new Response(Bun.file("index.html"), {
        headers: { "Content-Type": "text/html; charset=utf-8" },
      });
    }

    if (url.pathname === "/client.js") {
      return new Response(Bun.file("public/client.js"), {
        headers: { "Content-Type": "application/javascript; charset=utf-8" },
      });
    }
    return new Response("Not Found", { status: 404 });
  },
});

console.log(`Server running at http://localhost:${port}`);
export { server };
