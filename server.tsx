// server.ts - Bun HTTP server serving index.html, bundled client, and API endpoints

const port = 3001;

import { createOpencodeClient } from "@opencode-ai/sdk";

import { listMessages } from "./src/oc-client";
import { shouldReuseSummary } from "./src/hash";

await loadIps();

function resolveBaseUrl(ip: string) {
  return `http://${ip}:2000`;
}

// Per-IP ephemeral session cache (5s TTL)
interface CachedSessions {
  list: { id: string; title?: string }[];
  fetchedAt: number;
}
const cachedSessionsByIp: Record<string, CachedSessions | null> = {};
// Per-session summary cache to avoid repeated summarizer calls when no new messages
const summaryCacheBySession: Record<
  string,
  { messageHash: string; summary: string; action: boolean; cachedAt: number }
> = {};

// Track in-flight asynchronous summarization per session key to avoid duplicate calls
const SUMMARY_DEBOUNCE_MS = 2000; // delay before starting summarization to batch bursts
const summaryDebounceTimers: Record<string, ReturnType<typeof setTimeout>> = {};
const inFlightSummary: Record<string, boolean> = {};

// NEW: lightweight message count cache to let advanced SSE reuse counts generated by messages SSE
// Key format: `${ip}::${sessionId}`; TTL is implicit via freshness check (<=5s) before reuse
const messageCountCache: Record<string, { count: number; updatedAt: number }> =
  {};
const MESSAGE_COUNT_FRESH_MS = 5000;
// Advanced aggregated state persistent across SSE reconnects for events view
// Key: `${ip}::${sessionId}`
interface AttemptRecord {
  label?: string;
  url?: string;
  ok?: boolean;
  error?: string;
  status?: number;
  headers?: string[];
  rawStatus?: number;
  closed?: boolean;
  events?: number;
  durationMs?: number;
  notice?: string;
  keys?: string[];
  directId?: string;
  nestedId?: string;
  sinceMs?: number;
}
import type { Msg } from "./src/modules/sessions/session-manager";
interface AdvancedAggregatedState {
  meta: { ip: string; sessionId: string; createdAt: number };
  counts: {
    totalEvents: number;
    upstreamEvents: number;
    syntheticMessageUpdates: number;
  };
  lastMessage: { role: string; text: string };
  lastMessages: Msg[];
  messageCount: number;
  parts: Record<string, { type: string; text: string; updatedAt: number }>;
  lastTypes: string[];
  lastEventTs: number;
  reconnects: number;
  summary: string;
  actionFlag: boolean;
  shareUrl?: string;
}
const advancedAggregatedStateBySession: Record<
  string,
  AdvancedAggregatedState
> = {};
function createAggregatedState(
  ip: string,
  sid: string,
): AdvancedAggregatedState {
  return {
    meta: { ip, sessionId: sid, createdAt: Date.now() },
    counts: { totalEvents: 0, upstreamEvents: 0, syntheticMessageUpdates: 0 },
    lastMessage: { role: "", text: "" },
    lastMessages: [] as Msg[],
    messageCount: 0,
    parts: {},
    lastTypes: [] as string[],
    lastEventTs: 0,
    reconnects: 0,
    summary: "",
    actionFlag: false,
    shareUrl: undefined,
  };
}

// Derive share URL for a session (best-effort; cached short TTL via advancedAggregatedState)
function deriveShareUrlForSession(ip: string, sid: string): string | undefined {
  try {
    const aggKey = `${ip}::${sid}`;
    const agg = advancedAggregatedStateBySession[aggKey];
    if (agg && typeof agg.shareUrl === "string" && agg.shareUrl)
      return agg.shareUrl;
  } catch {}
  const base = resolveBaseUrl(ip);
  try {
    // Fetch detail; SDK first then raw fallback
    const client = createOpencodeClient({ baseUrl: base });
    return Promise.resolve((client as any).session.get?.({ path: { id: sid } }))
      .then((d: any) => {
        console.log("deriveShareUrlForSession sdk.get raw", {
          ip,
          sid,
          keys: d && Object.keys(d || {}),
          val: d,
        });
        const url =
          d?.share?.url ||
          d?.data?.share?.url ||
          d?.share_url ||
          d?.data?.share_url;
        if (typeof url === "string" && url) {
          try {
            const aggKey = `${ip}::${sid}`;
            const agg =
              advancedAggregatedStateBySession[aggKey] ||
              (advancedAggregatedStateBySession[aggKey] = createAggregatedState(
                ip,
                sid,
              ));
            agg.shareUrl = url;
          } catch {}
          return url;
        }
        return undefined;
      })
      .catch(() =>
        fetch(`${base}/session/${sid}`)
          .then((r) => (r.ok ? r.json().catch(() => null) : null))
          .then((j: any) => {
            console.log("deriveShareUrlForSession raw fetch detail", {
              ip,
              sid,
              val: j,
            });
            const url =
              j?.share?.url ||
              j?.data?.share?.url ||
              j?.share_url ||
              j?.data?.share_url;
            if (typeof url === "string" && url) {
              try {
                const aggKey = `${ip}::${sid}`;
                const agg =
                  advancedAggregatedStateBySession[aggKey] ||
                  (advancedAggregatedStateBySession[aggKey] =
                    createAggregatedState(ip, sid));
                agg.shareUrl = url;
              } catch {}
              return url;
            }
            return undefined;
          })
          .catch(() => undefined),
      ) as any;
  } catch {
    return undefined;
  }
}

// Rendering helpers
import {
  renderSessionDetailPage,
  renderSessionAdvancedPage,
  renderSessionsListPage,
} from "./rendering";
import { renderAutoScrollScriptEvent } from "./rendering/fragments";

import { dataStarPatchElementsString } from "./rendering/datastar";
import {
  AdvancedSdkJson,
  AdvancedInfo,
  AdvancedEvents,
  AdvancedRecentMessages,
} from "./rendering/fragments";
import { SessionsUl } from "./rendering/lists";
import { doesIpExist, getIpStore, loadIps } from "./src/utils/store-ips";

// Read persisted summarizer session id (if any) for highlighting; returns string or undefined
async function readSummarizerId(): Promise<string | undefined> {
  try {
    const text = await Bun.file("playpen/summarizer-config.json").text();
    const data = JSON.parse(text);
    const id =
      data && typeof data.summarizerSessionId === "string"
        ? data.summarizerSessionId
        : undefined;
    return id;
  } catch {
    return undefined;
  }
}

// Fetch sessions fresh for an IP (no cache usage, but populates cache for quick create-session reflection)
async function fetchSessionsFresh(ip: string) {
  const base = resolveBaseUrl(ip);
  console.log("sessions fetch start", { ip, base });
  try {
    const client = createOpencodeClient({ baseUrl: base });
    const remote = await client.session.list().catch((e: any) => {
      console.warn("SDK session.list error", {
        ip,
        msg: (e && e.message) || String(e),
      });
      return null;
    });
    console.log("SDK session.list raw", {
      ip,
      type: remote && typeof remote,
      keys: remote && Object.keys(remote as any),
      value: remote,
    });
    let list: { id: string; title?: string }[] = [];
    if (Array.isArray(remote)) {
      list = remote.map((r) => ({ id: r.id, title: r.title }));
    } else if (remote && typeof remote === "object") {
      const arr = (remote as any).data || (remote as any).sessions;
      if (Array.isArray(arr))
        list = arr.map((r: any) => ({ id: r.id, title: r.title }));
    }
    if (!list.length) {
      try {
        const rawRes = await fetch(`${base}/session`);
        console.log("raw /session status", { ip, status: rawRes.status });
        if (rawRes.ok) {
          const rawJson = await rawRes.json().catch((e: any) => {
            console.warn("raw /session json parse error", {
              ip,
              msg: (e && e.message) || String(e),
            });
            return null;
          });
          console.log("raw /session json", { ip, value: rawJson });
          const rawArr = Array.isArray(rawJson)
            ? rawJson
            : rawJson?.sessions || rawJson?.data;
          if (Array.isArray(rawArr))
            list = rawArr.map((r: any) => ({ id: r.id, title: r.title }));
        }
      } catch (e) {
        console.warn("raw /session fetch error", {
          ip,
          msg: (e as Error).message,
        });
      }
    }
    const now = Date.now();
    const existing = cachedSessionsByIp[ip];
    if (existing) {
      existing.list = list;
      existing.fetchedAt = now;
    } else {
      cachedSessionsByIp[ip] = { list, fetchedAt: now };
    }
    console.log("sessions fetch complete", { ip, count: list.length });
    return list;
  } catch (e) {
    console.error("Failed to list sessions", ip, (e as Error).message);
    return [];
  }
}

// SSE of sessions for an IP
function sessionsSSE(ip: string): Response {
  let interval: ReturnType<typeof setInterval> | undefined;
  const stream = new ReadableStream({
    async start(controller) {
      async function push() {
        try {
          const list = await fetchSessionsFresh(ip);
          const statusJsx = (
            <div id="sessions-status" class="status">
              {`Updated ${new Date().toLocaleTimeString()}`}
            </div>
          );
          const summarizerId = await readSummarizerId();
          const sessionsListJsx = (
            <div id="sessions-list">
              <SessionsUl ip={ip} sessions={list} summarizerId={summarizerId} />
            </div>
          );
          try {
            controller.enqueue(
              new TextEncoder().encode(dataStarPatchElementsString(statusJsx)),
            );
            controller.enqueue(
              new TextEncoder().encode(
                dataStarPatchElementsString(sessionsListJsx),
              ),
            );
          } catch (e) {
            if (interval) clearInterval(interval);
            controller.close();
          }
        } catch (e) {
          console.error("Sessions SSE push error", (e as Error).message);
        }
      }
      await push();
      interval = setInterval(push, 5000);
    },
    cancel() {
      if (interval) clearInterval(interval);
    },
  });
  return new Response(stream, {
    headers: {
      "Content-Type": "text/event-stream; charset=utf-8",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive",
      "Access-Control-Allow-Origin": "*",
    },
  });
}

// Fetch messages for a session at IP
async function fetchMessages(ip: string, sessionId: string) {
  const base = resolveBaseUrl(ip);
  try {
    const textMessages = await listMessages(base, sessionId);
    return textMessages.map((msg) => ({
      role: msg.role,
      text: msg.texts.join("\n"),
      parts: msg.texts.map((text) => ({ type: "text", text })),
    }));
  } catch (e) {
    console.error(
      "Failed to fetch messages",
      ip,
      sessionId,
      (e as Error).message,
    );
    return [];
  }
}

// Legacy messagesSSE removed; advanced events stream now handles messages + summary.

const server = Bun.serve({
  port,
  async fetch(req: Request) {
    const url = new URL(req.url);

    // Sessions list SSE for given IP: /sessions/:ip/stream
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/stream")
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, 'stream']
      if (parts.length === 3) {
        const ip = parts[1];
        if (!doesIpExist(ip))
          return new Response("Unknown IP", { status: 404 });
        return sessionsSSE(ip);
      }
    }

    // Create session for IP: POST /sessions/:ip/create-session
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/create-session") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions','ip','create-session']
      if (parts.length === 3) {
        const ip = parts[1];
        if (!doesIpExist(ip))
          return new Response("Unknown IP", { status: 404 });
        try {
          const bodyText = await req.text();
          let title = "new session";
          if (bodyText) {
            try {
              const parsed = JSON.parse(bodyText);
              if (typeof parsed.title === "string" && parsed.title.trim())
                title = parsed.title.trim();
            } catch {
              /* ignore */
            }
          }
          const base = resolveBaseUrl(ip);
          const client = createOpencodeClient({ baseUrl: base });
          let created: any;
          try {
            created = await client.session.create({ body: { title } });
            console.log("SDK session.create raw:", created);
          } catch (e) {
            console.warn(
              "SDK create failed, trying raw endpoint:",
              (e as Error).message,
            );
            const rawRes = await fetch(`${base}/session`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify({ title }),
            });
            if (!rawRes.ok) throw new Error(`Create ${rawRes.status}`);
            created = await rawRes.json();
          }
          let sessionId = (created as any)?.id;
          if (!sessionId) {
            const data = (created as any)?.data || created;
            sessionId = data?.id;
          }
          if (!sessionId || typeof sessionId !== "string")
            throw new Error(
              `Session creation returned invalid ID: ${JSON.stringify(created)}`,
            );
          // Inject into per-IP cache
          const entry = {
            id: sessionId,
            title: (created as any)?.title || title,
          };
          const now = Date.now();
          const existing = cachedSessionsByIp[ip];
          if (existing) {
            const ids = new Set(existing.list.map((s) => s.id));
            if (!ids.has(entry.id)) existing.list.unshift(entry);
            existing.fetchedAt = now;
          } else {
            cachedSessionsByIp[ip] = { list: [entry], fetchedAt: now };
          }

          const stream = dataStarPatchElementsString(
            <div
              id="create-session-result"
              class="result"
              data-init={`location.href='/sessions/${ip}/${entry.id}'`}
            >
              Created session:{" "}
              <a href={`/sessions/${ip}/${entry.id}`}>{entry.id}</a>
            </div>,
          );
          return new Response(stream, {
            headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          });
        } catch (e) {
          const msg = (e as Error).message;
          const errorJsx = (
            <div id="create-session-result" class="result">
              Error: {msg}
            </div>
          );
          return new Response(dataStarPatchElementsString(errorJsx), {
            headers: { "Content-Type": "text/event-stream; charset=utf-8" },
            status: 500,
          });
        }
      }
    }

    // Delete session for IP: POST /sessions/:ip/:sid/delete-session
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/delete-session") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'delete-session']
      if (parts.length === 4 && parts[3] === "delete-session") {
        const ip = parts[1];
        const sid = parts[2];
        if (!doesIpExist(ip))
          return new Response("Unknown IP", { status: 404 });
        let deletedOk = false;
        const base = resolveBaseUrl(ip);
        try {
          const client = createOpencodeClient({ baseUrl: base });
          try {
            const d = await (client as any).session.delete?.({
              path: { id: sid },
            });
            if (
              d &&
              (d.id === sid ||
                (d as any).data?.id === sid ||
                (d as any).ok ||
                (d as any).status === "ok")
            ) {
              deletedOk = true;
            }
          } catch (e) {
            console.warn("SDK delete failed", (e as Error).message);
          }
          if (!deletedOk) {
            try {
              const rawRes = await fetch(`${base}/session/${sid}`, {
                method: "DELETE",
              });
              if (rawRes.ok) deletedOk = true;
            } catch {}
          }
        } catch (e) {
          console.error("Delete session route error", (e as Error).message);
        }
        if (deletedOk) {
          const cache = cachedSessionsByIp[ip];
          if (cache && Array.isArray(cache.list)) {
            cache.list = cache.list.filter((s) => s.id !== sid);
          }
        }
        // Refresh list (best effort)
        await fetchSessionsFresh(ip).catch(() => null);
        const cache = cachedSessionsByIp[ip];
        const list = cache?.list || [];
        const stream =
          dataStarPatchElementsString(
            <div
              id="delete-session-result"
              class="result"
              data-init={deletedOk ? `location.href='/sessions/${ip}'` : ""}
            >
              {deletedOk
                ? `Deleted session: ${sid}`
                : "Delete failed or session not found"}
            </div>,
          ) +
          dataStarPatchElementsString(
            <div id="sessions-list">
              <SessionsUl
                ip={ip}
                sessions={list}
                summarizerId={await readSummarizerId()}
              />
            </div>,
          );
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          status: deletedOk ? 200 : 500,
        });
      }
    }
    // Share session for IP: POST /sessions/:ip/:sid/share-session
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/share-session") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'share-session']
      if (parts.length === 4 && parts[3] === "share-session") {
        const ip = parts[1];
        const sid = parts[2];
        if (!doesIpExist(ip))
          return new Response("Unknown IP", { status: 404 });
        let sharedOk = false;
        const base = resolveBaseUrl(ip);
        try {
          const client = createOpencodeClient({ baseUrl: base });
          try {
            const d = await (client as any).session.share?.({
              path: { id: sid },
            });
            if (
              d &&
              (d.id === sid ||
                (d as any).data?.id === sid ||
                (d as any).ok ||
                (d as any).status === "ok")
            ) {
              sharedOk = true;
            }
          } catch (e) {
            console.warn("SDK share failed", (e as Error).message);
          }
          if (!sharedOk) {
            try {
              const rawRes = await fetch(`${base}/session/${sid}/share`, {
                method: "POST",
              });
              if (rawRes.ok) sharedOk = true;
            } catch {}
          }
        } catch (e) {
          console.error("Share session route error", (e as Error).message);
        }
        let shareUrl: string | undefined;
        if (sharedOk) {
          try {
            const base2 = resolveBaseUrl(ip);
            const detailRes = await fetch(`${base2}/session/${sid}`);
            if (detailRes.ok) {
              const json = await detailRes.json().catch(() => null);
              shareUrl =
                json?.share?.url ||
                json?.data?.share?.url ||
                json?.share_url ||
                json?.data?.share_url;
              if (typeof shareUrl === "string" && shareUrl) {
                try {
                  const aggKey = `${ip}::${sid}`;
                  const agg =
                    advancedAggregatedStateBySession[aggKey] ||
                    (advancedAggregatedStateBySession[aggKey] =
                      createAggregatedState(ip, sid));
                  agg.shareUrl = shareUrl;
                } catch {}
              }
            }
          } catch {}
        }
        const stream = dataStarPatchElementsString(
          <div id="share-session-result" class="result">
            {sharedOk
              ? `Shared session: ${sid}${shareUrl ? " | " + shareUrl : ""}`
              : "Share failed or session not found"}
          </div>,
        );
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          status: sharedOk ? 200 : 500,
        });
      }
    }
    // Unshare session for IP: POST /sessions/:ip/:sid/unshare-session
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/unshare-session") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'unshare-session']
      if (parts.length === 4 && parts[3] === "unshare-session") {
        const ip = parts[1];
        const sid = parts[2];
        if (!doesIpExist(ip))
          return new Response("Unknown IP", { status: 404 });
        let unsharedOk = false;
        const base = resolveBaseUrl(ip);
        try {
          const client = createOpencodeClient({ baseUrl: base });
          try {
            const d = await (client as any).session.unshare?.({
              path: { id: sid },
            });
            if (
              d &&
              (d.id === sid ||
                (d as any).data?.id === sid ||
                (d as any).ok ||
                (d as any).status === "ok")
            ) {
              unsharedOk = true;
            }
          } catch (e) {
            console.warn("SDK unshare failed", (e as Error).message);
          }
          if (!unsharedOk) {
            try {
              const rawRes = await fetch(`${base}/session/${sid}/unshare`, {
                method: "POST",
              });
              if (rawRes.ok) unsharedOk = true;
            } catch {}
          }
        } catch (e) {
          console.error("Unshare session route error", (e as Error).message);
        }
        const stream = dataStarPatchElementsString(
          <div id="share-session-result" class="result">
            {unsharedOk
              ? `Unshared session: ${sid}`
              : "Unshare failed or session not found"}
          </div>,
        );
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          status: unsharedOk ? 200 : 500,
        });
      }
    }
    // Clear all sessions for IP: POST /sessions/:ip/clear-sessions
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/clear-sessions") &&
      req.method === "POST"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions','ip','clear-sessions']
      if (parts.length === 3 && parts[2] === "clear-sessions") {
        const ip = parts[1];
        if (!doesIpExist(ip))
          return new Response("Unknown IP", { status: 404 });
        let deletedCount = 0;
        let total = 0;
        const base = resolveBaseUrl(ip);
        try {
          // Fetch latest list to ensure we attempt all existing sessions
          const list = await fetchSessionsFresh(ip);
          const ids = list
            .map((s) => s.id)
            .filter((id) => typeof id === "string" && id.trim());
          total = ids.length;
          for (const sid of ids) {
            let deletedOk = false;
            try {
              const client = createOpencodeClient({ baseUrl: base });
              try {
                const d = await (client as any).session.delete?.({
                  path: { id: sid },
                });
                if (
                  d &&
                  (d.id === sid ||
                    (d as any).data?.id === sid ||
                    (d as any).ok ||
                    (d as any).status === "ok")
                ) {
                  deletedOk = true;
                }
              } catch (e) {
                console.warn("SDK delete failed (bulk)", (e as Error).message);
              }
              if (!deletedOk) {
                try {
                  const rawRes = await fetch(`${base}/session/${sid}`, {
                    method: "DELETE",
                  });
                  if (rawRes.ok) deletedOk = true;
                } catch {}
              }
            } catch (e) {
              console.error(
                "Bulk delete session error",
                sid,
                (e as Error).message,
              );
            }
            if (deletedOk) deletedCount++;
          }
        } catch (e) {
          console.error("Clear sessions route error", (e as Error).message);
        }
        // Reset cache for IP (will be repopulated on next fetch)
        const cache = cachedSessionsByIp[ip];
        if (cache) cache.list = [];
        // Best-effort refresh (in case some deletions failed and we want fresh remaining list)
        await fetchSessionsFresh(ip).catch(() => null);
        const afterCache = cachedSessionsByIp[ip];
        const remainingList = afterCache?.list || [];
        const stream =
          dataStarPatchElementsString(
            <div id="delete-session-result" class="result">
              {`Cleared sessions: ${deletedCount} / ${total}`}
            </div>,
          ) +
          dataStarPatchElementsString(
            <div id="sessions-list">
              <SessionsUl
                ip={ip}
                sessions={remainingList}
                summarizerId={await readSummarizerId()}
              />
            </div>,
          );
        return new Response(stream, {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
          status: 200,
        });
      }
    }
    // Deprecated legacy messages SSE replaced: use /sessions/:ip/:sid/messages/stream for detail view; advanced page continues using /sessions/:ip/:sid/advanced/events/stream.

    // Advanced raw JSON endpoint removed (manual fetch disabled)

    // Advanced SDK JSON: GET /sessions/:ip/:sid/advanced/sdk-json
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/advanced/sdk-json") &&
      req.method === "GET"
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'advanced','sdk-json']
      if (
        parts.length === 5 &&
        parts[3] === "advanced" &&
        parts[4] === "sdk-json"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!doesIpExist(ip))
          return new Response("Unknown IP", { status: 404 });
        const base = resolveBaseUrl(ip);
        let sdkDetail: any = null;
        let sdkList: any = null;
        let rawDetail: any = null;
        const attempts: AttemptRecord[] = [];
        try {
          const client = createOpencodeClient({ baseUrl: base });
          // Attempt multiple shapes for session.get
          async function tryGet(label: string, fn: () => Promise<any>) {
            try {
              const val = await fn();
              if (val) {
                const directId = (val as any).id;
                const nestedId = (val as any).data?.id;
                const okMatch = directId === sid || nestedId === sid;
                attempts.push({
                  label,
                  ok: okMatch,
                  keys: Object.keys(val || {}),
                  directId,
                  nestedId,
                });
                if (okMatch && !sdkDetail) sdkDetail = val;
              } else {
                attempts.push({ label, ok: false });
              }
            } catch (e) {
              attempts.push({ label, ok: false, error: (e as Error).message });
            }
          }
          await tryGet("params.id", () =>
            (client as any).session.get?.({ path: { id: sid } }),
          );
          if (!sdkDetail)
            await tryGet("params.session_id", () =>
              (client as any).session.get?.({ params: { session_id: sid } }),
            );
          if (!sdkDetail)
            await tryGet("body.id", () =>
              (client as any).session.get?.({ body: { id: sid } }),
            );
          if (!sdkDetail)
            await tryGet("body.session_id", () =>
              (client as any).session.get?.({ body: { session_id: sid } }),
            );
          if (!sdkDetail)
            await tryGet("direct.id", () =>
              (client as any).session.get?.({ id: sid }),
            );
          // Raw fetch fallback for comparison if still missing
          if (!sdkDetail) {
            try {
              const rawRes = await fetch(`${base}/session/${sid}`);
              if (rawRes.ok) rawDetail = await rawRes.json().catch(() => null);
              attempts.push({
                label: "raw.fetch",
                ok: !!rawDetail,
                rawStatus: rawRes.status,
              });
            } catch (e) {
              attempts.push({
                label: "raw.fetch",
                ok: false,
                error: (e as Error).message,
              });
            }
          }
          try {
            sdkList = await client.session.list().catch((e: any) => {
              console.warn(
                "SDK session.list error",
                (e && e.message) || String(e),
              );
              return null;
            });
          } catch {}
        } catch (e) {
          console.warn("SDK init error", (e as Error).message);
        }
        const payload = {
          sdkDetail,
          sdkListSummary: Array.isArray(sdkList)
            ? sdkList.map((s) => ({ id: s.id, title: s.title }))
            : sdkList,
          attempts,
          rawDetail,
        };
        const jsonText = JSON.stringify(payload, null, 2);
        // Pass raw JSON; JSX will escape inside <textarea>
        const sdkJsonJsx = <AdvancedSdkJson jsonText={jsonText} />;
        return new Response(dataStarPatchElementsString(sdkJsonJsx), {
          headers: { "Content-Type": "text/event-stream; charset=utf-8" },
        });
      }
    }

    // Advanced events SSE: /sessions/:ip/:sid/advanced/events/stream (batched, truncation)
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/advanced/events/stream")
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'advanced','events','stream']
      if (
        parts.length === 6 &&
        parts[3] === "advanced" &&
        parts[4] === "events" &&
        parts[5] === "stream"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!doesIpExist(ip))
          return new Response("Unknown IP", { status: 404 });
        // Buffer of last raw event lines (JSON strings)
        const eventBuffer: string[] = [];
        const attempts: AttemptRecord[] = [];
        const MAX_BUFFER = 100;
        const MAX_FIELD_LEN = 500; // truncate oversize data field values
        let lastPatchTs = 0;
        let pendingPatch = false;
        const PATCH_INTERVAL_MS = 400; // batch frequent events
        let upstreamController: AbortController | undefined;
        let upstreamClosed = false;
        let closed = false;
        const scheduledTimeouts = new Set<ReturnType<typeof setTimeout>>();
        // Candidate upstream SSE endpoints to probe relative to base
        const base = resolveBaseUrl(ip);
        const candidates = [
          `${base}/events`,
          `${base}/event`,
          `${base}/session/${sid}/events`,
          `${base}/session/${sid}/event`,
          `${base}/session/${sid}/stream`,
        ];
        // Aggregated state (derived from upstream + synthetic events)
        // Persist across SSE reconnects using global map keyed by ip::sessionId
        const aggKey = `${ip}::${sid}`;
        // Global store defined above caches; create if missing
        if (!advancedAggregatedStateBySession[aggKey]) {
          advancedAggregatedStateBySession[aggKey] = {
            meta: { ip, sessionId: sid, createdAt: Date.now() },
            counts: {
              totalEvents: 0,
              upstreamEvents: 0,
              syntheticMessageUpdates: 0,
            },
            lastMessage: { role: "", text: "" }, // last single message snapshot
            lastMessages: [] as any[], // last <=10 full messages (role,text,parts)

            messageCount: 0,
            parts: {},
            lastTypes: [] as string[],
            lastEventTs: 0,
            reconnects: 0,
            summary: "",
            actionFlag: false,
          };
        } else {
          // Mark reconnect for visibility
          advancedAggregatedStateBySession[aggKey].reconnects =
            (advancedAggregatedStateBySession[aggKey].reconnects || 0) + 1;
        }
        const aggregatedState = advancedAggregatedStateBySession[aggKey];
        const MAX_STATE_JSON_LEN = 4000;
        function applyEventToState(obj: any) {
          aggregatedState.counts.totalEvents++;
          aggregatedState.lastEventTs = Date.now();
          const type = (obj?.data && obj.data.type) || obj?.event || "";
          if (typeof type === "string" && type) {
            aggregatedState.lastTypes.push(type);
            if (aggregatedState.lastTypes.length > 50)
              aggregatedState.lastTypes.splice(
                0,
                aggregatedState.lastTypes.length - 50,
              );
          }
          // Message part updates
          if (
            obj?.data &&
            typeof obj.data === "object" &&
            !Array.isArray(obj.data)
          ) {
            try {
              if (type === "message.part.updated") {
                const part =
                  (obj.data as any).part || (obj.data as any).data?.part;
                if (part && typeof part === "object") {
                  const pid = part.id || part.part_id || part.partId;
                  if (pid) {
                    aggregatedState.parts[pid] = {
                      type: part.type,
                      text:
                        typeof part.text === "string"
                          ? part.text.substring(0, 300)
                          : "",
                      updatedAt: Date.now(),
                    };
                    // Prune parts map if too large (keep last 200 by updatedAt)
                    const keys = Object.keys(aggregatedState.parts);
                    if (keys.length > 200) {
                      const sorted = keys.sort(
                        (a, b) =>
                          aggregatedState.parts[a].updatedAt -
                          aggregatedState.parts[b].updatedAt,
                      );
                      const remove = sorted.slice(0, keys.length - 200);
                      for (const k of remove) delete aggregatedState.parts[k];
                    }
                  }
                }
              }
              if (type === "session.message.update") {
                aggregatedState.counts.syntheticMessageUpdates++;
                if (typeof obj.data.count === "number")
                  aggregatedState.messageCount = obj.data.count;
                if (typeof obj.data.role === "string")
                  aggregatedState.lastMessage.role = obj.data.role;
                if (typeof obj.data.text === "string")
                  aggregatedState.lastMessage.text = obj.data.text.substring(
                    0,
                    600,
                  );
              }
            } catch {}
          }
        }
        function serializeAggregatedState() {
          try {
            const json = JSON.stringify(aggregatedState, null, 2);
            return json.length > MAX_STATE_JSON_LEN
              ? json.substring(0, MAX_STATE_JSON_LEN) + "..."
              : json;
          } catch {
            return "";
          }
        }
        // Helper to push patch of AdvancedEvents fragment
        function enqueuePatch(controller: ReadableStreamDefaultController) {
          if (closed) return; // guard after closure
          try {
            const stateJson = serializeAggregatedState();
            const statusJsx = (
              <div
                id="messages-status"
                class="status"
              >{`Updated ${new Date().toLocaleTimeString()}`}</div>
            );
            const jsx = (
              <AdvancedEvents
                events={eventBuffer}
                attempts={attempts}
                stateJson={stateJson}
              />
            );
            // Recent messages fragment from aggregated state
            const recentMsgs = Array.isArray(aggregatedState.lastMessages)
              ? aggregatedState.lastMessages
              : [];
            const summaryText = aggregatedState.summary || undefined;
            const actionFlag = aggregatedState.actionFlag || false;
            const totalCount =
              aggregatedState.messageCount || recentMsgs.length;
            const recentJsx = (
              <AdvancedRecentMessages
                messages={recentMsgs as any}
                summaryText={summaryText}
                actionFlag={actionFlag}
                totalCount={totalCount}
              />
            );
            controller.enqueue(
              new TextEncoder().encode(dataStarPatchElementsString(statusJsx)),
            );
            controller.enqueue(
              new TextEncoder().encode(dataStarPatchElementsString(recentJsx)),
            );
            controller.enqueue(
              new TextEncoder().encode(dataStarPatchElementsString(jsx)),
            );
            controller.enqueue(
              new TextEncoder().encode(renderAutoScrollScriptEvent()),
            );
            lastPatchTs = Date.now();
            pendingPatch = false;
          } catch (e) {
            // If controller is closed, mark closed to suppress future patches
            console.error(
              "Advanced events enqueue error",
              (e as Error).message,
            );
          }
        }
        // Open first successful candidate
        async function openFirst(controller: ReadableStreamDefaultController) {
          let candidateIndex = 0;
          async function tryNext() {
            if (candidateIndex >= candidates.length) return; // exhausted
            const urlStr = candidates[candidateIndex++];
            const attempt: any = { url: urlStr, ok: false };
            attempts.push(attempt);
            let startTs = Date.now();
            try {
              upstreamController = new AbortController();
              const res = await fetch(urlStr, {
                signal: upstreamController.signal,
              });
              attempt.status = res.status;
              attempt.headers = Array.from(res.headers.keys());
              if (!res.ok) {
                attempt.error = `status ${res.status}`;
                return tryNext();
              }
              const contentType = res.headers.get("content-type") || "";
              if (!/text\/event-stream/i.test(contentType)) {
                attempt.error = "not event-stream";
                return tryNext();
              }
              attempt.ok = true;
              const reader = res.body?.getReader();
              if (!reader) {
                attempt.error = "no body reader";
                return tryNext();
              }
              (async () => {
                const decoder = new TextDecoder();
                let buffered = "";
                let eventCount = 0;
                try {
                  while (true) {
                    const chunk = await reader.read();
                    if (chunk.done) break;
                    buffered += decoder.decode(chunk.value, { stream: true });
                    let idx;
                    while ((idx = buffered.indexOf("\n\n")) !== -1) {
                      const rawEvent = buffered.slice(0, idx).trim();
                      buffered = buffered.slice(idx + 2);
                      if (!rawEvent) continue;
                      const lines = rawEvent.split(/\n+/);
                      const obj: any = { raw: rawEvent };
                      for (const line of lines) {
                        const m = line.match(/^(event|data|id|retry):\s*(.*)$/);
                        if (m) {
                          const key = m[1];
                          const val = m[2];
                          if (key === "data") {
                            let parsed: any = null;
                            try {
                              parsed = JSON.parse(val);
                            } catch {}
                            obj.data = parsed || val;
                          } else obj[key] = val;
                        }
                      }
                      // Truncate oversize string fields
                      if (
                        typeof obj.data === "string" &&
                        obj.data.length > MAX_FIELD_LEN
                      )
                        obj.data = obj.data.substring(0, MAX_FIELD_LEN) + "...";
                      if (
                        typeof obj.raw === "string" &&
                        obj.raw.length > MAX_FIELD_LEN
                      )
                        obj.raw = obj.raw.substring(0, MAX_FIELD_LEN) + "...";
                      applyEventToState(obj);
                      aggregatedState.counts.upstreamEvents++;
                      const jsonLine = JSON.stringify(obj);
                      eventBuffer.push(jsonLine);
                      eventCount++;
                      if (eventBuffer.length > MAX_BUFFER)
                        eventBuffer.splice(0, eventBuffer.length - MAX_BUFFER);
                      if (!pendingPatch) {
                        pendingPatch = true;
                        const now = Date.now();
                        const dueIn = Math.max(
                          0,
                          PATCH_INTERVAL_MS - (now - lastPatchTs),
                        );
                        const to = setTimeout(() => {
                          scheduledTimeouts.delete(to);
                          enqueuePatch(controller);
                        }, dueIn);
                        scheduledTimeouts.add(to);
                      }
                    }
                  }
                } catch (e) {
                  if ((e as any)?.name === "AbortError") {
                    console.warn("Upstream SSE aborted");
                  } else
                    console.error(
                      "Upstream SSE read error",
                      (e as Error).message,
                    );
                } finally {
                  upstreamClosed = true;
                  attempts.push({
                    url: urlStr,
                    closed: true,
                    events: eventCount,
                    durationMs: Date.now() - startTs,
                  });
                  // Retry next candidate if very few events and time short (<2s, <3 events)
                  if (eventCount < 3 && Date.now() - startTs < 2000) {
                    tryNext();
                  }
                  enqueuePatch(controller);
                }
              })();
            } catch (e) {
              attempt.error = (e as Error).message;
              return tryNext();
            }
            enqueuePatch(controller); // patch after starting attempt
          }
          await tryNext();
        }

        let heartbeat: ReturnType<typeof setInterval> | undefined;
        let messageInterval: ReturnType<typeof setInterval> | undefined;
        const stream = new ReadableStream({
          async start(controller) {
            const startTs = Date.now();
            await openFirst(controller);
            // Periodically fetch new messages for this session and append synthetic SSE entries.
            // This augments upstream generic events so Advanced view always reflects message flow.
            let lastMessageCount = 0;
            async function pollMessages() {
              try {
                const msgs = await fetchMessages(ip, sid);
                const count = msgs.length;
                // Update aggregated recent messages (always capture even if count unchanged to allow external inspection)
                const trimmed = count > 10 ? msgs.slice(-10) : msgs;
                aggregatedState.lastMessages = trimmed.map((m) => ({
                  role: m.role,
                  text: m.text,
                  parts: m.parts.map((p) => ({
                    type: "text",
                    text: p.text,
                  })) as { type: "text"; text: string }[],
                }));
                aggregatedState.messageCount = count;
                // Summary / action logic (mirrors messages SSE logic but integrated here)
                const cacheKey = `${ip}::${sid}`;
                const recentForHash = msgs.slice(-3).map((m: any) => ({
                  role: m.role || "message",
                  text: (m.parts?.[0]?.text || m.text || "")
                    .replace(/\s+/g, " ")
                    .trim(),
                }));
                const cached = summaryCacheBySession[cacheKey];
                const { hash: recentHash, reuse } = shouldReuseSummary(
                  cached?.messageHash,
                  recentForHash,
                );
                let summaryText = "(no recent messages)";
                if (count === 0) {
                  summaryText = "(no recent messages)";
                } else if (reuse && cached) {
                  summaryText = cached.summary;
                } else {
                  summaryText = "...";
                  // Debounce summary recompute only when last role is assistant
                  const lastRole = msgs[msgs.length - 1]?.role || "";
                  const shouldSummarize = lastRole === "assistant";
                  if (shouldSummarize && !inFlightSummary[cacheKey]) {
                    if (summaryDebounceTimers[cacheKey]) {
                      clearTimeout(summaryDebounceTimers[cacheKey]);
                      delete summaryDebounceTimers[cacheKey];
                    }
                    summaryDebounceTimers[cacheKey] = setTimeout(() => {
                      delete summaryDebounceTimers[cacheKey];
                      if (inFlightSummary[cacheKey]) return;
                      inFlightSummary[cacheKey] = true;
                      (async () => {
                        try {
                          const remoteBase = resolveBaseUrl(ip);
                          const { summarizeMessages } = await import(
                            "./src/oc-client"
                          );
                          const summ = await summarizeMessages(
                            remoteBase,
                            recentForHash,
                            sid,
                          );
                          if (summ.ok) {
                            summaryCacheBySession[cacheKey] = {
                              messageHash: recentHash,
                              summary: summ.summary || "(empty summary)",
                              action: summ.action,
                              cachedAt: Date.now(),
                            };
                          } else {
                            summaryCacheBySession[cacheKey] = {
                              messageHash: recentHash,
                              summary: "(summary failed)",
                              action: false,
                              cachedAt: Date.now(),
                            };
                          }
                        } catch (e) {
                          summaryCacheBySession[cacheKey] = {
                            messageHash: recentHash,
                            summary: "(summary failed)",
                            action: false,
                            cachedAt: Date.now(),
                          };
                        } finally {
                          const entry = summaryCacheBySession[cacheKey];
                          aggregatedState.summary = entry.summary;
                          aggregatedState.actionFlag = entry.action;
                          delete inFlightSummary[cacheKey];
                          if (!pendingPatch) {
                            pendingPatch = true;
                            const now2 = Date.now();
                            const dueIn2 = Math.max(
                              0,
                              PATCH_INTERVAL_MS - (now2 - lastPatchTs),
                            );
                            const to2 = setTimeout(() => {
                              scheduledTimeouts.delete(to2);
                              enqueuePatch(controller);
                            }, dueIn2);
                            scheduledTimeouts.add(to2);
                          }
                        }
                      })();
                    }, SUMMARY_DEBOUNCE_MS);
                  }
                }
                const previousSummary = aggregatedState.summary;
                // Determine action flag from cached or summary text
                const cacheAfter = summaryCacheBySession[cacheKey];
                const actionFlag = cacheAfter
                  ? cacheAfter.action
                  : /\|\s*action\s*=\s*yes/i.test(summaryText);
                aggregatedState.summary = summaryText;
                aggregatedState.actionFlag = actionFlag;
                // If summary updated (reuse or placeholder change) schedule patch even if count unchanged
                if (previousSummary !== summaryText && !pendingPatch) {
                  pendingPatch = true;
                  const now3 = Date.now();
                  const dueIn3 = Math.max(
                    0,
                    PATCH_INTERVAL_MS - (now3 - lastPatchTs),
                  );
                  const to3 = setTimeout(() => {
                    scheduledTimeouts.delete(to3);
                    enqueuePatch(controller);
                  }, dueIn3);
                  scheduledTimeouts.add(to3);
                }
                if (count !== lastMessageCount) {
                  // Only append synthetic event when count changes.
                  const latest = msgs[msgs.length - 1];
                  const payload: any = {
                    type: "session.message.update",
                    count,
                    role: latest?.role,
                    text:
                      latest?.parts?.slice(-1)[0]?.text || latest?.text || "",
                  };
                  const synthetic = {
                    raw: "data: " + JSON.stringify(payload),
                    data: payload,
                  };
                  applyEventToState(synthetic);
                  const jsonLine = JSON.stringify(synthetic);
                  eventBuffer.push(jsonLine);
                  if (eventBuffer.length > MAX_BUFFER)
                    eventBuffer.splice(0, eventBuffer.length - MAX_BUFFER);
                  lastMessageCount = count;
                  if (!pendingPatch) {
                    pendingPatch = true;
                    const now = Date.now();
                    const dueIn = Math.max(
                      0,
                      PATCH_INTERVAL_MS - (now - lastPatchTs),
                    );
                    const to = setTimeout(() => {
                      scheduledTimeouts.delete(to);
                      enqueuePatch(controller);
                    }, dueIn);
                    scheduledTimeouts.add(to);
                  }
                }
              } catch (e) {
                attempts.push({
                  notice: "message poll error",
                  error: (e as Error).message,
                });
                if (!pendingPatch) enqueuePatch(controller);
              }
            }
            // Initial poll and interval every 2s (align with messages SSE cadence)
            await pollMessages();
            messageInterval = setInterval(pollMessages, 2000);
            // No-events timeout notice
            setTimeout(() => {
              if (eventBuffer.length === 0) {
                attempts.push({
                  notice: "no events received yet",
                  sinceMs: Date.now() - startTs,
                });
                enqueuePatch(controller);
              }
            }, 5000);
            // Heartbeat to update status if upstream closed without new events
            heartbeat = setInterval(() => {
              if (upstreamClosed) {
                enqueuePatch(controller);
              }
            }, 5000);
          },
          cancel() {
            closed = true;
            if (heartbeat) clearInterval(heartbeat);
            if (upstreamController) upstreamController.abort();
            if (messageInterval) clearInterval(messageInterval);
            for (const to of scheduledTimeouts) clearTimeout(to);
            scheduledTimeouts.clear();
          },
        });
        return new Response(stream, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8",
            "Cache-Control": "no-cache, no-transform",
            Connection: "keep-alive",
            "Access-Control-Allow-Origin": "*",
          },
        });
      }
    }

    // Advanced session SSE: /sessions/:ip/:sid/advanced/stream
    if (
      url.pathname.startsWith("/sessions/") &&
      url.pathname.endsWith("/advanced/stream")
    ) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, 'advanced','stream']
      if (
        parts.length === 5 &&
        parts[3] === "advanced" &&
        parts[4] === "stream"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!doesIpExist(ip))
          return new Response("Unknown IP", { status: 404 });
        let sessionTitle = "";
        try {
          const cache = cachedSessionsByIp[ip];
          if (cache && Array.isArray(cache.list)) {
            const found = cache.list.find((s) => s.id === sid);
            if (found && typeof found.title === "string")
              sessionTitle = found.title.trim();
          }
        } catch {}
        let interval: ReturnType<typeof setInterval> | undefined;
        const stream = new ReadableStream({
          async start(controller) {
            async function push() {
              try {
                const cacheKey = `${ip}::${sid}`;
                let approxCount = 0;
                const cachedCount = messageCountCache[cacheKey];
                const fresh =
                  cachedCount &&
                  Date.now() - cachedCount.updatedAt <= MESSAGE_COUNT_FRESH_MS;
                if (fresh) {
                  approxCount = cachedCount.count;
                } else {
                  // Fallback: fetch messages for count only (reuse existing function)
                  const msgs = await fetchMessages(ip, sid);
                  approxCount = msgs.length;
                  messageCountCache[cacheKey] = {
                    count: approxCount,
                    updatedAt: Date.now(),
                  };
                }
                const displayTitle = sessionTitle || sid;
                const statusJsx = (
                  <div id="advanced-status" class="status">
                    {`Updated ${new Date().toLocaleTimeString()}`}
                  </div>
                );
                const shareUrl = await deriveShareUrlForSession(ip, sid);
                const infoWrapperJsx = (
                  <AdvancedInfo
                    title={displayTitle}
                    approxCount={approxCount}
                    shareUrl={shareUrl}
                  />
                );
                controller.enqueue(
                  new TextEncoder().encode(
                    dataStarPatchElementsString(statusJsx),
                  ),
                );
                controller.enqueue(
                  new TextEncoder().encode(
                    dataStarPatchElementsString(infoWrapperJsx),
                  ),
                );
              } catch (e) {
                console.error("Advanced SSE push error", (e as Error).message);
              }
            }
            await push();
            interval = setInterval(push, 5000);
          },
          cancel() {
            if (interval) clearInterval(interval);
          },
        });
        return new Response(stream, {
          headers: {
            "Content-Type": "text/event-stream; charset=utf-8",
            "Cache-Control": "no-cache, no-transform",
            Connection: "keep-alive",
            "Access-Control-Allow-Origin": "*",
          },
        });
      }
    }

    // Session detail page: GET /sessions/:ip/:sid
    if (url.pathname.startsWith("/sessions/")) {
      const parts = url.pathname.split("/").filter(Boolean); // ['sessions', ip, sid, maybe 'advanced']
      if (
        parts.length === 3 &&
        req.method === "GET" &&
        parts[0] === "sessions"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!getIpStore().includes(ip)) return Response.redirect("/", 302);
        // Validate session exists (best effort)
        try {
          const base = resolveBaseUrl(ip);
          const client = createOpencodeClient({ baseUrl: base });
          let exists = false;
          try {
            const detail = await (client as any).session.get?.({
              path: { id: sid },
            });
            if (detail && detail.id === sid) exists = true;
          } catch {
            /* ignore */
          }
          if (!exists) {
            try {
              const rawRes = await fetch(`${base}/session/${sid}`);
              if (rawRes.ok) {
                const rawJson = await rawRes.json().catch(() => null);
                if (rawJson && rawJson.id === sid) exists = true;
              }
            } catch {
              /* ignore */
            }
          }
          if (!exists) {
            try {
              const list = await client.session.list();
              exists =
                Array.isArray(list) && list.some((s: any) => s.id === sid);
            } catch {
              /* ignore */
            }
          }
          if (!exists)
            return Response.redirect(
              `/sessions/${encodeURIComponent(ip)}`,
              302,
            );
        } catch {
          /* ignore */
        }
        let sessionTitle = "";
        try {
          const base = resolveBaseUrl(ip);
          const cache = cachedSessionsByIp[ip];
          if (cache && Array.isArray(cache.list)) {
            const found = cache.list.find((s) => s.id === sid);
            if (found && typeof found.title === "string")
              sessionTitle = found.title.trim();
          }
          if (!sessionTitle) {
            try {
              const client2 = createOpencodeClient({ baseUrl: base });
              const list2 = await client2.session.list().catch(() => []);
              if (Array.isArray(list2)) {
                const found2 = list2.find((s: any) => s && s.id === sid);
                if (found2) {
                  const t =
                    (found2 as any).title || (found2 as any).data?.title;
                  if (typeof t === "string" && t.trim())
                    sessionTitle = t.trim();
                }
              }
            } catch {}
          }
          if (!sessionTitle) {
            try {
              const rawRes2 = await fetch(`${base}/session/${sid}`);
              if (rawRes2.ok) {
                const rawJson2 = await rawRes2.json().catch(() => null);
                if (rawJson2 && rawJson2.id === sid) {
                  const t =
                    (rawJson2 as any).title || (rawJson2 as any).data?.title;
                  if (typeof t === "string" && t.trim())
                    sessionTitle = t.trim();
                }
              }
            } catch {}
          }
        } catch {}
        const page = renderSessionDetailPage({
          ip,
          sessionId: sid,
          sessionTitle,
        });
        return new Response(page, {
          headers: { "Content-Type": "text/html; charset=utf-8" },
        });
      }
      // Advanced session page: GET /sessions/:ip/:sid/advanced
      if (
        parts.length === 4 &&
        req.method === "GET" &&
        parts[0] === "sessions" &&
        parts[3] === "advanced"
      ) {
        const ip = parts[1];
        const sid = parts[2];
        if (!doesIpExist(ip)) return Response.redirect("/", 302);
        // Reuse title lookup from detail page (best effort)
        let sessionTitle = "";
        try {
          const cache = cachedSessionsByIp[ip];
          if (cache && Array.isArray(cache.list)) {
            const found = cache.list.find((s) => s.id === sid);
            if (found && typeof found.title === "string")
              sessionTitle = found.title.trim();
          }
        } catch {}
        const page = renderSessionAdvancedPage({
          ip,
          sessionId: sid,
          sessionTitle,
        });
        return new Response(page, {
          headers: { "Content-Type": "text/html; charset=utf-8" },
        });
      }
      // Sessions list page: GET /sessions/:ip
      if (
        parts.length === 2 &&
        req.method === "GET" &&
        parts[0] === "sessions"
      ) {
        const ip = parts[1];
        if (!doesIpExist(ip)) return Response.redirect("/", 302);
        const page = renderSessionsListPage({ ip });
        return new Response(page, {
          headers: { "Content-Type": "text/html; charset=utf-8" },
        });
      }
    }

    // Home page
    if (url.pathname === "/" || url.pathname === "/index.html") {
      return new Response(Bun.file("index.html"), {
        headers: { "Content-Type": "text/html; charset=utf-8" },
      });
    }

    if (url.pathname === "/client.js") {
      // Dynamic on-demand build with in-memory cache. Rebuild when any source file mtime changes.
      try {
        // Simple dependency list; in a larger app consider a manifest or glob hash.
        const baseSources = [
          "src/client/index.ts",
          "render.ts",
          "rendering/index.ts",
          "rendering/datastar.ts",
        ];
        const glob = new Bun.Glob("src/client/**/*.{ts,tsx}");
        const sources = [
          ...baseSources,
          ...Array.from(glob.scanSync({ cwd: "." })).filter(
            (p) => p !== "src/client/index.ts",
          ),
        ];
        interface BuildCacheEntry {
          code: string;
          builtAt: number;
          mtimes: Record<string, number>;
        }
        // @ts-ignore augment globalThis for cache reuse across hot reloads (same process)
        if (!globalThis.__clientBuildCache) globalThis.__clientBuildCache = {};
        // @ts-ignore
        const cache: { entry?: BuildCacheEntry } =
          globalThis.__clientBuildCache;
        function currentMtimes() {
          const out: Record<string, number> = {};
          for (const s of sources) {
            try {
              out[s] = Bun.file(s).lastModified;
            } catch {
              out[s] = 0;
            }
          }
          return out;
        }
        const mtimes = currentMtimes();
        let needRebuild = false;
        if (!cache.entry) needRebuild = true;
        else {
          for (const s of sources) {
            if (cache.entry.mtimes[s] !== mtimes[s]) {
              needRebuild = true;
              break;
            }
          }
        }
        if (needRebuild) {
          const build = await Bun.build({
            entrypoints: ["src/client/index.ts"],
            target: "browser",
            minify: false,
          });
          if (!build.success) {
            const firstErr = build.logs[0]?.message || "build failed";
            return new Response(`// build error: ${firstErr}`, {
              headers: {
                "Content-Type": "application/javascript; charset=utf-8",
              },
              status: 500,
            });
          }
          const output = build.outputs[0];
          const code = await output.text();
          cache.entry = { code, builtAt: Date.now(), mtimes };
        }
        const codeToSend = cache.entry
          ? cache.entry.code
          : "// no build output";
        return new Response(codeToSend, {
          headers: {
            "Content-Type": "application/javascript; charset=utf-8",
            "Cache-Control": "no-cache",
          },
        });
      } catch (e) {
        return new Response(
          `// dynamic build exception ${(e as Error).message}`,
          {
            headers: {
              "Content-Type": "application/javascript; charset=utf-8",
            },
            status: 500,
          },
        );
      }
    }
    return new Response("Not Found", { status: 404 });
  },
});

console.log(`Server running at http://localhost:${port}`);
export { server };
